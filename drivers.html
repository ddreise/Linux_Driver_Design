<html>
<head>
<title>Device Driver Development</title>
</head>
<body>
<p></p>
<h1>Contents</h1>
<p><a href="#ch1">Chapter 1 - Drivers: The Rationale</a><br /><a href="#ch2">Chapter 2 - Introduction to Linux Driver Framework</a><br /><a href="#ch3">Chapter 3 - Introduction to Linux Character Drivers</a><br /><a href="#ch4">Chapter 4 - Linux Character Drivers - Talking to Hardware</a><br /><a href="#ch5">Chapter 5 - Linux Character Drivers - One Module, Multiple Devices</a><br /><a href="#ch6">Chapter 6 - Linux Character Drivers - I/O Control</a><br /><a href="#ch7">Chapter 7 - Linux Interrupt Handling</a><br /><a href="#ch8">Chapter 8 - Linux USB Driver Basics</a><br /><a href="#ch9">Chapter 9 - Intro to Windows Driver Development</a><br /><a href="#ch10">Chapter 10 - Fleshing out an NT Driver</a><br /><a href="#ch11">Chapter 11 - WDM Driver Basics</a><br /><a href="#ch12">Chapter 12 - WDF in a Nutshell</a><br /><a name="ch1"></a></p>
<h1>Device Driver Development :: The Rationale</h1>
<p>This document will provide some introductory material to help launch a student towards the ability to understand and eventually develop device drivers for Microsoft Windows or Linux.</p>
<p>A great, and free, resource you can use to learn about Linux device drivers can be found here:</p>
<p><a href="https://lwn.net/Kernel/LDD3/">https://lwn.net/Kernel/LDD3/</a></p>
<p>This is the Linux Device Drivers 3rd Edition.</p>
<h2>What is a Device Driver</h2>
<p>A driver is an extension of an operating system's <i>kernel</i>. As we have seen in both Operating Systems Fundamentals, as well as RTOS, the kernel has the responsibility to provide services to applications that run on top of the OS, and part of this responsibility is to provide convenient access to system hardware resources in a way that shields the end user application from direct access to such hardware.</p>
<p>Consider a typical RTOS environment. An application designer in such an environment may require the ability to send some data to another machine via an RS232 serial port built into the hardware of the platform. The operating system designer of this system will provide an OS service, perhaps called <kbd>SerialOutput (char *data, int len)</kbd>, which will allow a top level application to "send" data out via the RS232 serial port. On our 680x0 environment, we may have set up this service via TRAP #1, perhaps service number 7, using register A0 to point to the data, and register D0 to indicate the number of bytes. A top level wrapper function will take the C based function parameters and convert to the assembly level TRAP operations, as we had done in our RTOS course.</p>
<p>So what exactly will this <kbd>SerialOutput</kbd> service do on behalf of the top level application? After saving away application context, the OS will determine that the request maps to the RS232 access code for output purposes. Once the kernel dispatches support to the RS232 output code inside the OS, we are in a position to <b>DRIVE</b> the hardware. Driving hardware is nothing more than having some form of intelligent smarts built into our code that manipulates the hardware based on hardware manufacturer guidelines. In the case of an RS232 serial port, there will most likely be a data register mapped in at either an I/O address or memory mapped address, and the driving software will "poke" the appropriate byte from the incoming block of data to this address. The driving software will probably check some additional register for status information, such as "port busy", and if still busy, wait until the register indicates the port is free to accept another byte. This driving process will continue until all bytes in the block have been sent via the RS232 serial port.</p>
<p>Another potential implementation might see the OS maintain a queue of bytes that are to be sent to the serial port, and the serial port hardware (the UART) will have the ability to <i>interrupt</i> the kernel to indicate that it's OK to feed another byte out the port. Hence, rather than implement a busy-wait situation for checking status on the port as we described above, the hardware will interrupt to indicate the port is no longer busy, which is a much better use of CPU resources than busy-wait situations.</p>
<p>Thus, the interrupt handler for the serial port interrupt will have the responsibilty to take the next available byte from the queue, adjust the queue tail pointer accordingly, poke the byte into the port and return back to the current application. This process essentially takes care of feeding out the block of data without tying up the CPU by waiting for status to indicate it's OK to communicate via the serial port.</p>
<p>Both of these situations are typical of driver software. Be it busy-wait or interrupt based, driver software has the responsibility to manage the access and input/output to hardware in a way that allows such access to be reused effectively, and to eliminate potential corruption of hardware access where two or more top level applications may wish to do the same type of work. In an environment where there is no kernel based driver support, it is entirely possible for two applications to contend for the same hardware resource, and thus, while task switching, cause corruption of one app's access over another.</p>
<h2>Driver Support in an OS</h2>
<p>All modern operating systems will employ drivers, and most operating systems will dictate to hardware manufacturers HOW a driver should be implemented so that it meshes correctly with the OS.</p>
<p>In our example above, we discussed a serial port driver for a custom RTOS. What if we were not charged with the task of driving the RS232 ports on a Windows based PC? Where do we begin?</p>
<p>It should be obvious that we simply cannot just create an arbitrary blob of code to manipulate the 16550 UARTS that are available on most PC motherboards. Windows, as an OS, will protect a top level application from direct access to hardware resources of our PC. However, since Windows is designed to detect and support virtually ANY hardware that can be plugged into a motherboard, it's obvious that Microsoft itself cannot predict in advance what kind of hardware you might be using. Hence, Microsoft Windows expects a special kind of software known as a Device Driver, to be loaded to support access to the hardware. It is within the device driver that the arbitrary code to manipulate the appropriate hardware based on manufacturer's requirements. Windows thus is a fairly generic kernel environment - code that is able to run on all variations of x86 hardware makes up the basic kernel, and external driver files support all the myriad custom configurations that Windows somehow had to manage.</p>
<p>Note that Linux is essentially the same - the Linux kernel is generic, and drivers support the special dedicated access to all hardware resources.</p>
<p>So, if the kernel expects these driver files to deal with arbitrary hardware resources, does this imply that a driver will have a special "look and feel" from the software perspective? Or are driver designers able to implement any old pile of code to deal with the hardware?</p>
<h2>Basic Driver Model</h2>
<p>As alluded to in the previous section, drivers obviously cannot be completely arbitrary in their design. When Windows or Linux eventually need to feed a byte to some RS232 port, Windows or Linux will pass that level of functionality off to the driver. Thus, Windows or Linux will expect some form of <b>ENTRY POINT</b> to be available within the driver, that allows the host OS to request that the driver "do something" on behalf of the more generic kernel.</p>
<p>Consider our original simple RTOS designs. We did indeed write drivers for all the hardware we were expected to control, albeit, we wrote arbitrary, custom code that only our specially designed custom OS knew how to call. In many cases, we simply jumped directly to support subroutines within the kernel, as we merged our driver technology directly inline with our generic kernel support.</p>
<p>Now what would happen if we attempted to separate such functionality in our custom RTOS? Is it even possible? The answer is of course dependent on your level of design abilty, and your need to keep driver support independent of your kernel support. In many custom OS environments, this isn't a big issue, but if the hardware platform you design your OS for may change over the years via additions, or wholesale changes on the motherboard, then to preserve your investment in the kernel design, you will more than likely attempt to keep hardware drivers separate from generic kernel functionality.</p>
<p>So what can we do to make a driver "independent" of the kernel? In our RTOS environments, the support for <kbd>SerialOutput()</kbd> required knowledge of where the RS232 port is mapped into our hardware environment, and of course, the up front knowledge of the fact we were WRITING to the hardware is obvious due to the nature of the OS request. The act of writing required us to have DATA, and some sort of knowledge of HOW MUCH data is to be written. Thus, from the OS perspective, we can create an <b>ABSTRACTION</b> of the act of writing to the RS232 serial port quite easily by forcing the designer of the serial output support to provide to the kernel a lower level abstracted function known as <kbd>SerialByteOutput()</kbd>, which will manage the direct access to the hardware to feed one byte out the port. This low level function would thus be useful in either a busy-wait polling environment, as well as an interrupt based environment, as in both situations, the act of outputting something on the serial port will eventually devolve into poking a byte into the hardware.</p>
<p>So far, so good. The generic kernel will call this abstracted function called <kbd>SerialByteOutput()</kbd>, and as a result, the generic kernel has NO NEED to know anything about the hardware. All the "smarts" to talk to the hardware will be buried inside the lowest level abstracted function.</p>
<p>We can now expand on this abstraction. Here is a proposed list of things that a serial port may need to do on behalf of the kernel:</p>
<ul>
<ul>
<li><kbd>SerialByteOutput()</kbd> - as discussed above, this will support the output of a byte to the hardware according to manufacturer requirements</li>
<li><kbd>SerialByteOutputBusy()</kbd> - the kernel may need to know whether the byte output capability is currently busy actually performing that work, or if it's OK to proceed to poke the next byte out. This is important, as in many serial environments, hardware will revolve around a single data register, and thus, overwriting the contents of this register with new data before the current value is sent out will result in loss of data on the outgoing stream. This abstraction will thus monitor the "busy" flag of the serial port, to ensure we don't attempt to feed data out faster than its physically able to be output.</li>
<li><kbd>SerialByteInput()</kbd> - the kernel will eventually need to support the reading of data from the serial port, hence, this function will manage the abstracted access to the actual hardware and return the next avaialble byte from the port hardware.</li>
<li><kbd>SerialByteInputAvailable()</kbd> - similar to the output scenario, it only makes sense to attempt to input data if and only if an actual byte is avaiable in the port. Hence, this abstraction will need to support the ability to detect whether the flags register of the serial hardware indicates a byte has just been received, and thus, signal back to the generic kernel that it's OK to attempt a read at that time.</li>
</ul>
</ul>
<p><kbd>SerialPortConfiguration()</kbd></p>
<ul>- as we all know, a serial port needs a lot of configuration - baud rates, handshaking rules, bits per byte specification, start/stop bits, parity, and so forth. As an abstraction, the kernel may be able to supply either a series of parameters to this function, or a generalized structure, and the abstracted function will take the data and manipulate it in a way that makes sense to the actual hardware.</ul>
<p>That's a pretty good start to the design of a driver. What we've now done is decided upon is a list of ENTRY POINTS within the driver that the kernel can count upon. Hence, if hardware changes down the road, the kernel need not change, only the driver support. As long as the list of abstracted support can be linked into the kernel, the kernel will be happy, and the hardware will be happy.</p>
<p>Note that although this may seem like overhead, it only makes sense in the long term. The kernel should NOT be talking directly to hardware unless it's a one-off custom OS. The kernel should know that it will eventually NEED to talk to the hardware, but otherwise, keep its hands off. The abstraction layer that wraps the hardware will do all the nitty gritty work. And in fact, this keeps with typical software engineering practice, in that complicated work that has little to do with an overall algorithm should be foisted off to its own subroutine to preserve the readability and maintainabilty of the algorithm. All the lowest level hardware manipulation support doesn't add anything to the higher level process of managing a serial port, hence, even in a one-off custom OS, you would probably still call subroutines to do the nitty gritty work. In this scenario, all we've done is simply enumerate what functions SHOULD be there.</p>
<p>Armed with our enumerated list of functionality, a 3rd party is now able to implement support for the driver. The kernel can rest easy knowing that the 3rd party will provide all the required functionality, and as a result, the generic nature of the kernel is preserved.</p>
<p>The above now forms a very simple DRIVER MODEL that we can expand upon for future drivers within our OS.</p>
<h2>Interrupt based Driver Model</h2>
<p>It should be noted that the above sample list of entry points make sense in a polling environment. What about device driver support for devices that can generate interrupts?</p>
<p>We can easily expand on this by taking into account that a driver may require the ability to "hook" a given interrupt within the system. For a serial port on a PC, the interrupt request was usually IRQ 3 or 4. Hence, the driver must somehow tell the OS that it will be the software that handles the appropriate source of interrupt.</p>
<p>In our RTOS, we assumed that the vector table of the system will be stored within ROM, as many embedded OS environments use ROM to house both the bootstrap code as well as the entire operating system. An OS that loads via a disk or network source must have the flexibility to rewrite the vector table to suit its own needs, thus, vector tables for general purpose systems are often stored in RAM, like the PC hardware platform, or the Atari ST, Apple Macintosh, etc.</p>
<p>The OS will provide generalized interrupt handlers, and a driver can instruct an OS to "chain" or "override" the driver based handler in addition to any generalized handlers the OS may provide. For example, a custom OS may provide a generalized handler whose job it is to save CPU context in the current task's PDB, determine if any specific handler is in use, and if not, simply restore the current task's CPU context from its PDB and return from interrupt. Thus, the OS may need to maintain a table of entry points to interrupt handlers for all drivers that may load in after the OS starts up. This allows for drivers to be updated at runtime if necessary.</p>
<p>Some driver models require a driver designer to implement a table of entry points within the driver software image that is loaded from disk. The table will indicate what offset from the start of the software image on disk the code is to handle specific requests (reading/writing) or perhaps where an interrupt handler may be located. The OS can then take this information, combine it with the appropriate locations within RAM where the code is stored, and plug the entry point table with the appropriately updated information.</p>
<p>The interrupt support could then call upon the earlier polling support we discussed previously, to peek at hardware to obtain data, or to poke data back into hardware. Hence, the correct level of abstraction in a driver's design should ensure maintainable driver implementations.</p>
<p>Note that most modern OSes will NOT allow a driver to totally override an interrupt handler. MS-DOS was one of the few that allowed a driver (or heck, even application level software) to poke a new address into the vector table for arbitrary interrupt handlers to replace the OS supplied handler. This is dangerous, as it would then require the driver supplier to understand all the details about what the OS expects an interrupt to do, such as context save/restore, task swapping, and so forth. Instead, by having a table of entry points, the generalized interrupt handler can then perform the OS expected work, and jump off to the driver supplied subroutine to actually deal with the real task of managing the low level hardware that caused the interrupt.</p>
<p>Windows and Linux essentially follow the same concepts discussed above within their respective OS designs. Every driver you install for a given computer system running these OSes will follow some sort of driver model specified by the manufacterer of the respective OS. There are dozens of potential documents from each OS manufacturer that describe in excruciating detail exactly what entry points must be filled in by a driver, and what data is expected to be passed in our back from these entry points.</p>
<p>If a driver writer follows the rules, the driver will work as advertised. If it fails to work as the kernel expects, the OS may fail. Windows suffers from "BSOD" (blue screen of death) quite often especially when poorly written or faulty drivers are being used by the kernel. Linux as well will generate "kernel panics" when problems arise in 3rd party code that the kernel depends upon.</p>
<h2>Driver Use of System Resources</h2>
<p>At the start of this document, when we were building the rationale for why a device driver is necessary, we discussed the concept of hardware support that required the need for additional memory resources ... a system queue for outgoing data, and obviously, if there's input involved, then a system queue for incoming data, so that a driver is not stuck attempting to do busy-wait polling type management of hardware. Thus, in our interrupt based model above, the most intelligent method to manage incoming and outgoing data is to have the driver somehow allocate space to store these queue objects.</p>
<p>However, allocation implies some form of memory management service support. We know that the OS will provide services such as <kbd>alloc()</kbd> and <kbd>free()</kbd> which allow applications to allocatd and deallocate memory resources. The OS will handle the divvying up of the system heap, perhaps marking the fact that a given application owns a block of memory, and so forth. But here, it's the <i>driver</i> that may require the memory allocation support. Does it make sense for a driver to ask for system resources the same way that an application does? In an uprotected operating system, What would happen if a driver's memory resources get overwritten by an application that loses control over its pointers (addresses)? Obviously, there must be a separation of service support for applications and the kernal internally (which includes drivers).</p>
<p>Note that many modern OSes will have a whole raft of internal kernel level services that are designed to be used from <i>within</i> the kernal, rather than being accessed at the application level. This should hopefully enusre that the system resources for drivers will be pretty much guaranteed to work compared to application level software, as without a driver operational, the devices themselves would be rendered useless. The internal kernel level services may include physical and virtual memory management, file system management, logging and error reporting services, and perhaps dedicated device access services (communications directly between drivers).</p>
<h2>Driver Privileges</h2>
<p>It should be noted at this moment that it's very obvious that a driver is a PRIVILEGED chunk of code. It runs within the security and permissions level of the kernel, as obviously, the kernel will be calling upon the driver to do work on behalf of the generic kernel.</p>
<p>Thus, a fault in driver code will manifest itself as a fault in the OS, which can lead to top level virii exploits, or a failure of the system in general. Consider how many BSODs are recoverable to the point that you can continue using the system. Almost all faults that arise within a system cause the system to be rebooted in hopes of resolving the problem. Drivers are not casual pieces of code - great care must be taken to ensure issues like buffer overruns can never occur, that pointers are properly managed, and that resources that a driver might require, such as a block of internal memory, are requested and released properly. Nothing is worse than having a crappy driver eat up resources that could have been used by an application!</p>
<p>Different CPUs will have different capabilities in terms of management of "user mode" applications from within "kernel mode" control of the OS. For example, on the 680x0 platform, we had user and supervisor modes of CPU operation to distinguish these two layers. Intel x86 family CPUs from the 80386 on up have the 4 "ring" layers ... Ring 0 is for kernel/driver (OS) operations, and Ring 3 is for application layer operations.</p>
<p>Because of the high privilege levels afforded to drivers within an operating system environment, it is vital to ensure that no exploit can take place from within driver code. In fact, many OS manufacters now require driver manufacturers to subject their drivers to certifications to ensure they comply with rules regarding security and operational safety. This is why its sometimes difficult to locate drivers, as obscure or low volume hardware manufacturers may simply not have the financial means to subject themselves to this costly practice. This is why OSes like Windows will prompt an end user, when installing a driver that is not certified, whether they trust the source of the driver. If you inadvertently accepted the use of a driver that has purposely malicious code buried within its entry points, you're simply asking for trouble!</p>
<p>Although this sounds like it'll render the practice of creating drivers in a classroom setting almost impossible, thankfully, from a novice driver implementor's perspective, we can try out driver developent and simply tell the OS that we "trust ourselves" as the source of the driver. Again, accept uncertified drivers ONLY from sources you feel are trustworthy, as it simply doesn't pay to install uncertified software that can totally exploit the system at the privilege level of the OS itself!</p>
<h2>In Class Exercise #1 - 30 minutes</h2>
<p>The class will be divided into two teams, called TEAM-A and TEAM-B. The job of these teams is defined below:</p>
<p><b>TEAM-A</b></p>
<p>Using your knowledge of Microsoft Windows and the GDI (graphic device interface) subsystem, come up with a list of capabilities that a video driver must support in order to handle all of the GDI capabilities that Windows offers to an application programmer. Create a small presentation to highlight your findings.</p>
<p><b>TEAM-B</b></p>
<p>Using your knowledge of Microsoft Windows and the GDI (graphic device interface) subsystem, come up with a list of capabilities that a printer driver must support in order to handle all of the GDI capabilities that Windows offers to an application programmer. Create a small presentation to highlight your findings.</p>
<p>For both groups, in your research, consider some of the common services that an application programmer might call for devices like video displays or printers. For example, font plotting, line, rectangle and ellipse plotting, paper eject, and so forth. Try to come up with as comprehensive list as possible. Remember to consider generic kernel support as well as device level support - are there concepts that can be managed generically within GDI that do not necessarily need to be in a device driver? Or is it better to embed support into each driver for efficiency?</p>
<p>Note: do not worry about DirectX support here ... just look at GDI alone. DirectX is another story :-)</p>
<h2>In Class Exercise #2 - 30 minutes</h2>
<p>The class will be divided into two (different) teams, called TEAM-1 and TEAM-2. The job of these teams is defined below:</p>
<p><b>TEAM-1</b></p>
<p>Using your knowledge of Windows or Linux and file systems come up with a list of capabilities that a hard disk driver must support in order to deal with file system operations. Create a small presentation to highlight your findings.</p>
<p><b>TEAM-2</b></p>
<p>Using your knowledge of Windows or Linux and file systems come up with a list of capabilities that a flash memory stick driver (or USB jump drive or SD card reader, etc.) must support in order to deal with file system operations. Create a small presentation to highlight your findings.</p>
<p>For both groups, in your research, consider some of the common services that an application programmer might call for file system devices such as the ones above. Consider especially the generic concepts that all file systems support, versus the concepts that revolve explicitly around the actual communications to the hardware.</p>
<p></p>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch2"></a></span></span></p>
<h1>Device Driver Development :: Introduction to Linux Driver Framework</h1>
<p>This page will introduce you to the basic types of drivers you will encounter in the Linux environment. We will discuss the purpose behind each type of driver, and potential entry points that you may see within each type of driver, and finish with an introductory example of what a typical driver might require as minimal support.</p>
<h2>Driver Types</h2>
<p>Linux has a fairly simple list of device driver types. They fall into three basic categories:</p>
<ol>
<li><b>Block Device Drivers</b> - this driver class represents devices that represent a file system object, which will require large blocks of data to be transferred to and from an application, such as a disk, CD or DVD. These are devices that take some form of request from the file system (generally a large buffer of data), and performs the i/o operations to the disk mechanism to transfer the requested block of data. Block device drivers implement entry points for <kbd>read</kbd> and <kbd>write</kbd>, which allow for data to be moved back and forth from device to application. It should be noted that a block device can be <i>mounted</i> as an external file system, hence additional entry points will be required to allow this activity to take place. Another entry point for this class of driver is a subroutine called <kbd>strategy</kbd> which marshalls the control to support the transfer of data back and forth to/from the device.</li>
<li><b>Character Device Drivers</b> - this driver class represents devices that generally operate on a byte by byte basis (hence the name "character"). Block device drivers support the same list of entry points as do block devices, minus the special support for file system mounting, hence, to an end user, block and character devices often appear the same. An RS232 serial port is a good example of a device that would require character device driver support. There are two main entry points for this driver: <kbd>read</kbd> and <kbd>write</kbd>, which makes sense, as these are the two general operations that allow data to be transferred back and forth from the device.</li>
<li><b>Network Interface Drivers</b> - this driver class is responsible for support of network devices and interfaces. Network transactions are processed via devices that are able to exchange data with other computer systems (hosts). These may be hardware oriented (such as an actual network interface card driver), or software based (such as a local loopback driver).</li>
</ol>
<p>Note that there are also specialized types of drivers that support complex devices like video cards, that support fast application access to device capabilities (frame buffers, etc.).</p>
<p>The entry points briefly discussed above are standardized in Linux device driver development. When a driver is loaded and utilized, the OS expects the entry points to be available, so that it can dynamically link to the appropriate entry point to perform activity for the device. As we discussed last class, these entry points are standardized across all devices in their respective categories, to ensure that different manufacturers of similar devices can integrate their drivers cleanly with the Linux OS.</p>
<p>It should be noted that Linux refers to these drivers as <i>modules</i>, more precisely, Loadable Kernel Modules (LKM for short), which are built using standard software development tools (C/C++ compiler, custom headers and libraries, etc.), however, they're not executed like normal applications. There is no <kbd>main()</kbd> function for a module, instead, the appropriate entry points are exposed within the driver, and the OS knows how to call upon them at runtime after the driver is installed.</p>
<p>In fact, an LMK is <i>not allowed</i> to call up normal standard libary functionality - it can only link to kernel exported functionality. This means that you'll no longer have access to handy standard library functions like <kbd>printf()</kbd> and others, intead, you'll have "kernel versions" of many of these common functions.</p>
<h2>Introductory List of Driver Entry Points</h2>
<p>In addition to the 3 entry points listed above that we will discuss later (<kbd>strategy</kbd>, <kbd>read</kbd> and <kbd>write</kbd>), there are two other important entry points that must exist in all Linux device drivers/LKMs:</p>
<ul>
<li><kbd>init_module()</kbd> - this function will support the initialization of the driver software. Generally, a driver will register its capabilities with the OS at the time this entry point is called. A minimal driver <b>must</b> implement this entry point.</li>
<li><kbd>cleanup_module()</kbd> - this function will support the deinitialization of the driver software. Generally, a driver will deregister its capabilities with the OS at the time this entry point is called. A minimal driver <b>must</b> implement this entry point. The support of the above two entry points ensures that Linux can load and unload drivers upon administrator request, which is an obvious benefit to anyone trying to develop a new device driver!</li>
</ul>
<p>A minimal device driver will have both of the above implemented. Note that most modern frameworks for Linux driver development will have macros that allow you to call your functions whatever you like, and "register" your custom functions as "init" and "exit" routines. These macros will then ensure that the expected entry points are made available to the kernel.</p>
<h2>Building Our First Module</h2>
<p>As an exercise, we will now create a simple module that will announce its initialization and cleanup to the Linux logging system. The following code has been tested using Ubuntu Server version 8.04, as supplied to you as a Virtual PC session.</p>
<table border="1" bgcolor="#F0F0F0">
<tbody>
<tr>
<td>
<pre>/*
 * module1.c
 *
 * This is a first cut at a Linux driver module. This
 * module will simply announce its initialization and
 * cleanup to the system logs, which can be read via
 * a commandline such as:
 *
 * tail /var/log/syslog
 */


/*
 * special header files for Linux modules
 */

#include &lt;linux/version.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/time.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/stat.h&gt;


/*
 * announce our software license and authorship
 */

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Conestoga SET");


/*
 * static int __init initialize_my_module(void);
 *
 * This function will support the module initialization.
 * Note the use of the __init modifier for this function.
 */

static int __init initialize_my_module(void)
{
        printk(KERN_INFO "module1: Conestoga SET initialize_my_module() called.\n");
        return 0;
}

/*
 * static int __init cleanup_my_module(void);
 *
 * This function will support the module cleanup.
 * Note the use of the __exit modifier for this function.
 */

static void __exit cleanup_my_module(void)
{
        printk(KERN_INFO "module1: Conestoga SET cleanup_my_module() called.\n");
}


/*
 * these macros register the appropriate init and cleanup
 * functions that the Linux Kernel expects!
 */

module_init(initialize_my_module);
module_exit(cleanup_my_module);

</pre>
</td>
</tr>
</tbody>
</table>
<p>To be able to build the above module, you'll need to ensure your Ubuntu environment is configured to support the build of a Linux kernel. You will find the following two command lines useful to snag the appropriate build support for kernel or module development:</p>
<pre>To obtain the appropriate headers and other source support:

sudo apt-get install build-essential gdb linux-headers-$(uname -r)<br />sudo apt-get install libelf-dev

To obtain additional configuration and build support:

sudo apt-get install automake autoconf libtool
</pre>
<p>The Ubuntu virtual disk image provided for Virtual PC already has this installed.</p>
<p>You will need a <kbd>Makefile</kbd> to build this module:</p>
<pre>obj-m += module1.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
</pre>
<p>The first line indicates that we're adding our module1 source code (after compilation into an object module) to the list of kernel modules that are being built here. Note that the use of <kbd>obj-m</kbd> is customary to support the building of modules (rather than normal object files for applications). The target <kbd>all</kbd> will then invoke the appropriate internal makefile to build a module that uses <kbd>module1.o</kbd> as the module object file. The target <kbd>clean</kbd> would be used to clean up our development folder.</p>
<p>It's best to open another shell, and switch to root user mode using <kbd>sudo bash</kbd> to build our module. Once in root user mode, issue the commandline:</p>
<pre>make
</pre>
<p>to build your module. You'll of course be notified of any problems that arise from the build operation. <kbd>make</kbd> with no additional arguments will automatically build the target <kbd>all</kbd> as discussed earlier.</p>
<p>Once built, you can install and remove the module, and view the results stored in the system log file, via these commandlines (this assumes you're still in root user mode):</p>
<pre>insmod module1.ko
rmmod module1
tail /var/log/syslog
</pre>
<p>The first command installs the new kernel module called <kbd>module1.ko</kbd>. This is the output of the build operation you ran a few moments ago. The <kbd>module1.ko</kbd> is an object module that will be linked in with the kernel dynamically, upon invocation via <kbd>insmod</kbd> (install module).</p>
<p>Conversely, <kbd>rmmod</kbd> removes a module from the module list under its root name (in this case, <kbd>module1</kbd>.</p>
<p>Finally, the last command allows you to see the last few lines of the system messages log. The output from the "kernel print" function <kbd>printk()</kbd> will appear in this file. This print function normally would generate output on the console as the system boots up, but if you're building under a telnet or ssh shell, or in a Konsole or other X-Windows shell, you won't see the output. But it's always logged in the system log file for you to see afterwards.</p>
<p>You should see something like this in the <kbd>tail</kbd> output:</p>
<pre>Sep  2 16:24:46 ubuntuserver kernel: [27958.522924] module1: Conestoga SET initialize_my_module() called.
Sep  2 16:24:54 ubuntuserver kernel: [27967.039708] module1: Conestoga SET cleanup_my_module() called.
</pre>
<p>Congratulations! You have built your first module. It does absolutely nothing, but at least it hasn't brought the system down!</p>
<p>Now, onto some more beefy concepts in Linux driver development.</p>
<h2>In-Class Exercises</h2>
<ol>
<li>Using the supplied Ubuntu virtual disk, implement the above sample framework for the LKM called <kbd>module1</kbd>
<p></p>
</li>
<li>Using the sample code above, attempt to split the driver source code into two individual source code files: <kbd>mod2_init.c</kbd> and <kbd>mod2_cleanup.c</kbd>, and then compile and link into a single kernel object file that becomes the LKM called <kbd>module2</kbd>.
<p>Adjust the <kbd>Makefile</kbd> accordingly. Ensure you adjust the logging messages within this module to indicate it's <kbd>module2</kbd> that is generating the messages. Use this new <kbd>Makefile</kbd> as a starting point for future driver exercises.</p>
<p>It is recommended that you do this in a separate development folder to avoid corrupting or confusing the build process with other module files from earlier experiments. Follow this advice for all future modules you will experiment with and build on your own.</p>
</li>
</ol>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch3"></a></span></span></p>
<h1>Device Driver Development :: Introduction to Linux Character Drivers</h1>
<p>This page will discuss how to implement standard character device drivers in the Linux environment. We will assume that we're attempting to control a simple I/O device, such as a parallel port, or the PC speaker port, to help illustrate concepts such as read/write operations, I/O control operations, and so forth.</p>
<h2>Accessing Char Drivers from User Applications</h2>
<p>As was indicated in the previous chapter, user level applications in Linux can talk to a device via its driver module (the loadable kernel modules, or LKM for short), as modules are generally mapped into the Linux file system as file system objects in the <kbd>/dev</kbd> folder.</p>
<p>If you do an <kbd>ls -l</kbd> within the <kbd>/dev</kbd> folder in Linux, you will see a listing similar to the following:</p>
<pre>brw-r-----  1 root   disk      2,  68 2008-09-11 21:09 fd0u830
crw-rw-rw-  1 root   root      1,   7 2008-09-11 21:08 full
crw-rw----  1 root   fuse     10, 229 2008-09-11 21:08 fuse
crw-rw----  1 root   root     10, 228 2008-09-11 21:08 hpet
crw-r-----  1 root   kmem      1,   2 2008-07-21 13:13 kmem
crw-rw----  1 root   root      1,  11 2008-09-11 21:08 kmsg
brw-rw----  1 root   disk      7,   0 2008-07-21 13:13 loop0
brw-rw----  1 root   disk      7,   1 2008-09-11 21:10 loop1
brw-rw----  1 root   disk      7,   2 2008-09-11 21:10 loop2
brw-rw----  1 root   disk      7,   3 2008-09-11 21:10 loop3
brw-rw----  1 root   disk      7,   4 2008-09-11 21:10 loop4
brw-rw----  1 root   disk      7,   5 2008-09-11 21:10 loop5
brw-rw----  1 root   disk      7,   6 2008-09-11 21:10 loop6
brw-rw----  1 root   disk      7,   7 2008-09-11 21:10 loop7
crw-rw----  1 root   lp        6,   0 2008-09-11 21:10 lp0
crw-r-----  1 root   kmem      1,   1 2008-09-11 21:08 mem
crw-rw-rw-  1 root   root      1,   3 2008-07-21 13:13 null
</pre>
<p>This is a slightly culled listing, however, it helps to illustrate some of the concepts that allow our applications to be able to talk to support we embed within our loadable kernel modules.</p>
<p>Let's look at the device called "null". This is a "bit bucket", and is often used in situations such as:</p>
<pre>my_application &gt; /dev/null
</pre>
<p>The above commandline would allow my_application to run, but it redirects its output into a device called "null", which can be thought of as a "bit bucket" ... a convenient place to send unwanted data.</p>
<p>In the listing, it's shown with permission settings of <kbd>crw-rw-rw-</kbd> which makes sense for the most part. It's a "file" source/destination that has read/write permissions enabled for user, group and world, and no execution rights (as you really don't want to "execute" a module).</p>
<p>The first marker, wihch for a file is often just "-", or a folder is "d", is shown as "c". This helps identify the fact that <kbd>/dev/null</kbd> is a character mode driver, thus, it implements the facilities that a character mode driver is capable of implementing. This is our goal here, to implement our own custom character mode driver.</p>
<p>Furthermore, in the listing, you'll see that the owner is "root" and the group is "root", which makes sense, as many drivers are initialized and owned as root level objects. Where we would normally expect a file size, however, we see two numbers: 1, 3 in this case. The first is the MAJOR device number, and the second is the MINOR device number. Devices are internally registered to use a specific MAJOR/MINOR numbering scheme. You can see the scheme as it appears on your current Linux box by viewing this file: <kbd>/proc/devices</kbd> using <kbd>cat</kbd> or some other file output method.</p>
<p>From this file, you can see that major device number 1 is reserved for memory type devices, thus, the "null" device is a memory device (which sort of makes sense, as it's job is to suck content from whatever source provides it, much like writing data to the same memory location over and over - data is lost as a result).</p>
<h2>Installing Your Own Device Node</h2>
<p>This will be a two part operation: your LKM must register itself to have a specific major and minor device number pair, and a top level administrator or script must create a node that connects the major/minor device number pair to a file system object within <kbd>/dev</kbd>. Hence, the following work is often done during system boot up, using the initialization scripts that are provided for various devices in a Linux system, since your system always boots up in administrative (root user) mode.</p>
<p>Linux provides a utility command that allows a system administrator (or the system startup initialization files) to create "nodes" within the file system that represent convenient means to communicate to the modules under the hood. The utility is <kbd>mknod</kbd>, and is used as follows:</p>
<pre>mknod /dev/devicename c MAJOR MINOR
</pre>
<p>where <kbd>devicename</kbd> is the name of the device (from the user's perspective), and MAJOR and MINOR are the major and minor device numbers as discussed above. The node that is created is essentially the file system object name that gives us direct access to the driver from user level applications.</p>
<p>A kernel module can register itself to "own" a given major/minor device number pair via an internal kernel function called <kbd>register_chrdev_region()</kbd> which allows for 1 or more consecutive major/minor device numbers to be allocated. A alternative way to register device number usage is to have your LKM request a dynamically allocated major device number. This is done using a different kernel function called <kbd>alloc_chrdev_region()</kbd>, which allows the kernel to allocate the major number on your behalf. You will call either of these functions during the initialization portion of your LKM. In the cleanup portion, you will call <kbd>unregister_chrdev_region()</kbd> to deallocate your reservation of device numbers. The kernel function prototypes are as follows:</p>
<pre>#include &lt;linux/types.h&gt;
#include &lt;linux/kdev_t.h&gt;
#include &lt;linux/fs.h&gt;

int register_chrdev_region (dev_t first, unsigned int count, char *name);
</pre>
<p>Returns 0 to indicate success, a negative value for an error (thus, we will generally bail out of a module upon error). The object <kbd>dev_t</kbd> is really a 32 bit integer split into some number of bits for the MAJOR number and some number of bits for the minor number, and can be initialized using a macro:</p>
<pre>MKDEV (major, minor)
</pre>
<p>of course, you can extract the MAJOR and MINOR parts of a dev_t object using:</p>
<pre>MAJOR (dev_t)
MINOR (dev_t)
</pre>
<p>so there's always a way to go back and forth between these data types.</p>
<p>The parameter count is used to indicate how many devices you need starting at the first device specified, and the parameter name is the string representing the name that shows up in the /proc/devices file discussed earlier.</p>
<pre>int alloc_chrdev_region (dev_t *pDevice, unsigned int firstminor, unsigned int count, char *name);
</pre>
<p>Returns 0 to indicate it successfully found a major number with the supplied minor number for a list of devices specified by count. The parameter name is the same as above. The first parameter is supplied as a pointer to a dev_t object, hence, this function fills in the major number for you. If you need the major number, use the MAJOR() macro as discussed above.</p>
<pre>void unregister_chrdev_region (dev_t first, unsigned int count);
</pre>
<p>This function unregisters the reservation of device numbers from the first device specified by the dev_t parameter, and the value specified in count.</p>
<p>Note that for the most part, you'll generally be registering and unregistering ONE device per module, unless your module is meant to support multiple instances of a given hardware object, such as an RS232 port or parallel port (for example, we often have lp0, lp1 and so forth for the first parallel port, 2nd parallel port, and so forth).</p>
<p>If you choose to register your device numbers dynamically, AND because you must specify the minor number for the <kbd>alloc_chrdev_region()</kbd> function, a user level script or administrator that wishes to create a node in the <kbd>/dev</kbd> folder for your device can extract the major device number from <kbd>/proc/devices</kbd> by searching for the name you registered above. In many shell scripts that are used to install LKMs, you'll find code that looks like this to determine a dynamically allocated major number:</p>
<pre># get_major.sh

module="<i>your module name you register with</i>"
major = $(awk "\$2=="$module\" {print \$1}" /proc/devices
echo $major
</pre>
<p>The above would output the major number of whatever module you specified the name for during registration. The <kbd>awk</kbd> commandline is used for string processing (the job of <kbd>awk</kbd>), which in this case instructs <kbd>awk</kbd> to output the first column value of whatever line has a matching 2nd column value of the module name you specify. This is perfect, as the data in <kbd>/proc/devices</kbd> has the major number in the first column and the registered device name in the second column.</p>
<p>You'll see <kbd>awk</kbd> used extensively in shell scripts for string processing support such as this.</p>
<p>So, as a simple install script to install your LKM, to query the devices file to determine major number, and to then create a node within the <kbd>/dev</kbd> folder, you can use something similar to the script below. Note that you will need to modify the script for future examples and assignments, as this example assumes <kbd>module3</kbd> as the module in question.</p>
<pre># install.sh
#
# this script will install a specific module, and
# create a node by querying the /proc/devices file for
# the registered module name. You need to update this
# script for new modules you build in the future.
#
# remember, run this as a system admin (root user)


# adjust the value below for the name you register in your LKM
module="module3"

# adjust the value below for the name you wish to install
# in the file system
device="module3"

# install the LKM and exit if insmod fails with an error
insmod ./$module.ko || exit 1

# adjust the value below for the minor number your LKM registered
minor="0"

# query the /proc/devices file
major=$(awk "\$2==\"$module\" {print \$1}" /proc/devices)

# forcibly remove any existing file system devices (cleanup from
# previous attempts at running this script and to support
# situations where someone forgot to run the cleanup script below)
rm -f /dev/$device

# create the new file system node based on major/minor device numbers
mknod /dev/$device c $major $minor

# ensure device file is readable/writable by all
chmod 644 /dev/$device
</pre>
<p>The above script is easy to follow. Firstly, we initialize the name of the module we register within our LKM, and the device name we wish to expose within the <kbd>/dev</kbd> folder. Install the module using <kbd>insmod</kbd>, and if this utility fails, exit the script using <kbd>bash</kbd> script support.</p>
<p>We next initialize the minor value, and we'll query the major value which will now show up in <kbd>/proc/devices</kbd> after installing the module. Next, we'll remove any old nodes that might have been left over from previous executions of this script, and create a new node to represent our device within the <kbd>/dev</kbd> folder. Finally, we'll ensure the device node is readable and writable by all users, as that's the goal of creating a driver module - to support end user application access to devices!</p>
<p>To remove a module from use, use the following cleanup script:</p>
<pre># cleanup.sh
#
# this script will remove a specific module, and
# delete the node created earlier using the install.sh
#
# remember, run this as a system admin (root user)


# adjust the value below for the name you register in your LKM
module="module3"

# adjust the value below for the name you wish to install
# in the file system
device="module3"

# remove the LKM
rmmod $module

# forcibly remove any existing file system devices
rm -f /dev/$device
</pre>
<p>As you can see, it will perform an <kbd>rmmod</kbd> operation to remove the module from the modules list, and then forcibly remove the device node from the <kbd>/dev</kbd> folder. This ensures we're now clean for a future request to install a module.</p>
<p>Of course, to support the above, your module must obviously perform the appropriate device number reservations as discussed above.</p>
<p>Below are some examples of how you would support the initialization of the major/minor device numbers within your module.</p>
<pre>// use the same header files from last chapter's
// module1.c example, plus the following:

#include &lt;linux/types.h&gt;
#include &lt;linux/kdev_t.h&gt;
#include &lt;linux/fs.h&gt;

// use the same MODULE_LICENSE/AUTHOR data from last chapter


// NEW!!! 
// allocate 3 static global variables that will house the
// major, minor and final device number data for your module.

static int module_major = 0;
static int module_minor = 0;
static dev_t module_devicenumber;


static int __init
initialize_module (void)
{
	int rc;

	printk(KERN_INFO "module3: Conestoga SET initialize_module() called.\n");
	
	// NEW!!!!
	// allocate a major number for the minor number supplied, under the
	// name "module3" for this example.

        rc = alloc_chrdev_region (&amp;module_devicenumber, module_minor, 1, "module3");
        if (rc &lt; 0) {
                printk(KERN_INFO "module3: unable to allocate device region.\n");
                return rc;
        }       /* endif */

	// determine the allocated major number, and output to log file
	// what our major/minor numbers are

        module_major = MAJOR (module_devicenumber);
	printk (KERN_INFO "module3: during INIT ... major: %d minor: %d\n",
                module_major, module_minor);

	return 0;
}


// and don't forget to add in this line to the cleanup support, so that
// we deallocate our device number range ... we're using the globally
// saved dev_t object we allocated above during the init process ...

	unregister_chrdev_region (module_devicenumber, 1);
</pre>
<p>As you can see, this is a fairly painless procedure, and sets us up now to begin discussing the support for user level access to our driver.</p>
<h2>Kernel Structures to support File Operations</h2>
<p>As discussed in our introductory lesson, drivers for most operating systems will require the implementation of a table of entry points, that allow the generic portions of a given OS to call up the appropriate specific implementation details within a 3rd party driver.</p>
<p>Linux is no different.</p>
<p>Since we're implementing a character device driver for Linux, and character device drivers support file system access for support of operations like read, write, etc., it's natural to assume that we must supply entry points for these functions to the Linux kernel in some manner, just like how we supplied the initialization and cleanup entry points earlier.</p>
<p>In Linux, we use a special kernel structure, called <kbd>struct file_operations</kbd>, to supply these entry points. This is a comprehensive structure whose members are actually pointers to functions, that implement all the potential capabilities of a device driver, from the file system object perspective. Just like how we can "talk" to files in a file system, we can talk to drivers the same way, and this structure will connect the generic Linux support for files to the specifics that our driver will provide on behalf of the operating system.</p>
<p>This structure is defined within the <kbd>linux/fs.h</kbd> header file and has a list of members best described by visiting <a target="_blank" href="https://lwn.net/Kernel/LDD3/ch03.pdf" rel="noopener">Chapter 3</a> of the Linux Device Drivers, 3rd Ed. textbook, pages 49 through 53 (we'll call this textbook LDD3 from here on in).</p>
<p>It's customary in many drivers to create a module global variable that holds this structure, and only initialize the members that we wish to implement. The most C compilers, such as <kbd>gcc</kbd>, provides a convenient means of initializing structures that reduces overhead in our development.</p>
<p>Let's assume that our module3 LKM will implement support for <kbd>open</kbd> (opening the device file), <kbd>read</kbd> (reading from our sample driver) and <kbd>release</kbd> (closing the device file).</p>
<p>We would support the declaration of the file operations structure as such:</p>
<pre>static struct file_operations module3_fops = {
    .owner = THIS_MODULE,
    .open = module3_open,
    .read = module3_read,
    .release = module3_release
};
</pre>
<p>The <kbd>owner</kbd> member is used by the latest kernel (2.6 onwards) to support the prevention of unloading a kernel module before the file system usage has been completed. In the past, driver writers were responsible for maintaining usage counts of open/close operations, but no longer. For situations where you need to support older kernels, do some Google searches for <kbd>MOD_INC_USE_COUNT</kbd> and <kbd>MOD_DEC_USE_COUNT</kbd> as two macros that supported the increment and decrement of the module use count value. The increment was often implemented during the <kbd>open</kbd> support, and the decrement in the <kbd>release</kbd> support. If you are using these macros, you must not initialize the <kbd>owner</kbd> member!</p>
<p>As you can see, the syntax above sure beats the need to manually initialize EVERY member of the structure as is often done in C programming. Remember that a global variable will always have its value zero'ed out so the remaining members will be NULL, guaranteed.</p>
<p>In addition to setting up the file operations structure variable and initializing the members that we plan on implementing, we also must REGISTER this file operations structure with the Linux operating system. This is handled via another structure called <kbd>struct cdev</kbd>, which is defined in the <kbd>linux/cdev.h</kbd> header file.</p>
<p>Create a module global to house this data, such as <kbd>module3_cdev</kbd> as we've done in our sample code. We need to initialize our <kbd>cdev</kbd> structure, using the following code:</p>
<pre>    // initialize and register our character driver's file operations

    cdev_init (&amp;module3_cdev, &amp;module3_fops);
    module3_cdev.owner = THIS_MODULE;
    module3_cdev.ops = &amp;module3_fops;
    rc = cdev_add (&amp;module3_cdev, module3_devicenumber, 1);
    if (rc) {
        printk(KERN_INFO "module3: unable to add cdev struct.\n");
        return rc;
    }   /* endif */
</pre>
<p>The above code snippet illustrates the use of <kbd>cdev_init()</kbd> which setup up the <kbd>cdev</kbd> structure. We then configure the owner member and ops member of this structure accordingly. Finally, we register our character device (<kbd>cdev</kbd>) structure using <kbd>cdev_add()</kbd>, which ties the structure we provide with the device number we allocated earlier. This function will return non-zero to indicate an error, hence, we can bail out with an error condition if the registration process fails.</p>
<p>The above code snippet will end up in your initialization function for your module.</p>
<p>Of course, if we register something, at some point, we'll need to deregister. As expected, in our cleanup support, we'll do the following:</p>
<pre>    cdev_del (&amp;module3_cdev);
    unregister_chrdev_region (module3_devicenumber, 1);
</pre>
<p>The <kbd>cdev_del()</kbd> function cleans up the support structure for our character mode driver, followed by the unregistration function call as discussed previously. At this point, our character mode driver is fully deregistered!</p>
<h2>Introductory File Operations Specifics</h2>
<p>As documented in LDD3 on page 51 (Chapter 3), the support for <kbd>open()</kbd> is a function that looks like this:</p>
<pre>int module3_open (struct inode *i, struct file *fp);
</pre>
<p>We have two more structures to now contend with - the <kbd>struct inode</kbd> structure, which defines details about the inode that the file system uses to reference our device, and the <kbd>struct file</kbd> structure, which provides details about the file manipulation being done at the user level (the housekeeping details such as file position, etc.).</p>
<p><kbd>struct file</kbd> is actually the internally managed structure that the kernel deals with when a user level application uses a handle to reference a file. As an example, if the user level application uses <kbd>int lseek (int fh, int distance, int from_where);</kbd> to seek to some position within a file, the Linux kernel uses the file handle fh to reference the <kbd>struct file</kbd> structure internally within the OS, which manages the fact that the application has traversed so far from the start of the file.</p>
<p>The support for <kbd>read()</kbd> is similar:</p>
<pre>int module3_read (struct file *fp, char __user *buffer, size_t len, loff_t *offset);
</pre>
<p>Again we see the use of <kbd>struct file</kbd> here, as this will provide details about the user level file operation being done. The marker <kbd>__user</kbd> for the buffer indicates that the passed in address is from USER SPACE, not kernel space, thus, we need some special treatment as to how to copy data into user space from an LKM. We will discuss this shortly.</p>
<p>Finally, the support for <kbd>release()</kbd> is as such:</p>
<pre>int module3_release (struct inode *i, struct file *fp);
</pre>
<p>You will find details on <kbd>struct inode</kbd> and <kbd> struct file</kbd> in <a target="_blank" href="https://lwn.net/Kernel/LDD3/ch03.pdf" rel="noopener">Chapter 3</a> of LDD3, pages 53 through 55 inclusive.</p>
<p>With the 3 file operations above supported, this allows a user mode application to open, read from, and close the module we are creating. Although we haven't actually talked to any real hardware as of yet, the demonstration implementation shown below will illustrate the basic layout and implementation details that will eventually allow us to talk to hardware.</p>
<h3>module3_open()</h3>
<p>First, let's study the module3_open() implementation:</p>
<pre>/*
 * int module3_open (struct inode *i, struct file *fp);
 *
 * This function is called when a user level application attempts to
 * open the device file (/dev/module3 for example). This will
 * initialize our "pretend data source" of an array that holds some
 * formatted data (a counte of the number of times we've successfully opened
 * the module). It'll set up a global pointer to this data, so that calls to
 * the module3_read() function can properly manage the data stream available.
 */

int
module3_open (struct inode *i, struct file *fp)
{
    static int counter = 0; // use to count successful opens
    int x;
    char buffer[100];
    char tmp[100];

    printk (KERN_INFO "module3: module3_open starting ... \n");

    // we will limit out char driver to only allow one
    // user app to connect at one time. why? does it make
    // sense for two or more apps to try to read from some sort
    // of hardware simultaneously? Think of a serial port. If two
    // apps attempt to read, how would the stream of bytes being
    // received or sent be distributed to two applications??
    // Hence, return an error code (EBUSY in this case)

    if (module3_flagopen) {
        return -EBUSY;
    }   /* endif */

    module3_flagopen++;

    // create some sample data for our "driver" to feed out upon read() request
    // five lines of information (helps to prove how read support will work

    counter++;

    sprintf (buffer, "Welcome to module 3, this is access number %d\n", counter);
    strcpy (module3_sampledata, "");

    for (x = 0; x &lt; 5; x++) {
        sprintf (tmp, "line %d ... ", x + 1);
        strcat (module3_sampledata, tmp);
        strcat (module3_sampledata, buffer);
    }   /* end for */

    module3_sampledata_pointer = module3_sampledata;
    printk (KERN_INFO "module3: module3_open ... counter = %d \n", counter);

    // all is well!

    return 0;
}   /* end module3_open */
</pre>
<p>In our sample implementation, you'll notice we're using a module global flag variable called <kbd>module3_flagopen</kbd> to signal to our implementation that an open() request has already been started, but hasn't finished from a previous request. Since the goal will be to eventually talk to hardware, you need to consider if allowing two or more user level application to successfully communicate simultaneously is a viable concept. For many hardware devices, it does not make sense to have more than one instance of a device "open" at the user level.</p>
<p>Consider an RS232 serial port. If application A opens the port for reading, and begins to receive data, and application B also opens the port, how should the bytes be distributed between the two programs? Does A get one byte and B get the next? It doesn't make sense to allow two programs to have the serial port open. Windows is similar ... if one program opens COM1, and a second program attempts to do the same, the second request fails.</p>
<p>Hence, if we detect we're already open (a true value for the open flag variable) we then return the error code -EBUSY (normally, zero indicates success).</p>
<p>If nobody has the device opened, we continue, and we'll flag it as opened. A static local variable called <kbd>counter</kbd> is used to keep track of how many successful open requests have been processed by our module.</p>
<p>We next build a kludged up block of data for use by our module. Since we haven't yet learned now to talk to hardware, we need to simulate a stream of data, hence, we build up a string that uses the <kbd>counter</kbd> value for uniqueness, and copy that into a large global buffer 5 times to simulate multiple lines of text coming from our "device". Our global buffer is called <kbd>module3_sampledata</kbd> of 1000 bytes, and we have a global pointer that is used to mimic the movement through the sample data buffer, as if we were reading a stream of live bytes from a piece of hardware. This allows us to simulate the situation where we "run out of data" when this pointer reaches the null terminator of the string stored in the buffer.</p>
<p>At this point, the device has been successfully opened!</p>
<h3>module3_read()</h3>
<p>This implementation is a bit more tricky, as you'll see below:</p>
<pre>int module3_read (struct file *fp, char __user *buffer, size_t len, loff_t *offset)
{
    int bytes_read = 0;
    int curr_len;

    printk (KERN_INFO "module3: module3_read ... \n");

    // ensure we don't attempt to feed out our sample data beyond
    // the size of our string we've fudged in the open() support above

    curr_len = strlen (module3_sampledata_pointer);
    if (curr_len &lt; 0)
        return 0;

    // ensure we supply correct # bytes to user who requests data

    if (curr_len &gt; len)
        curr_len = len;

    copy_to_user (buffer, module3_sampledata_pointer, curr_len);
    module3_sampledata_pointer += curr_len;
    bytes_read = curr_len;

    return bytes_read;
}   /* end module3_read */
</pre>
<p>It's tricky in that we are dealing with a special object that arrives as part of the parameter list. Notice the 2nd parameter, a char pointer called <kbd>buffer</kbd>. It's marked with attribute <kbd>__user</kbd>. This indicates that the pointer provided here is referencing USER MEMORY, rather than kernel memory!</p>
<p>Hence, we cannot just copy or poke data directly to this buffer! Instead, we need to use one of a few kernel primitives that support the remapping of user memory into kernel memory. These primites are:</p>
<pre>// copy from kernel space to user space
unsigned long copy_to_user(void __user *to, const void *from, unsigned long n); 

// copy from user space to kernel space
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n); 

// a macro to copy a simple variable (byte, short, long) into user space
put_user (variable, ptr); 

// a macro to copy a simple variable (byte, short, long) from user space
get_user (variable, ptr); 
</pre>
<p>The two macros at the end of the above list are used when you're attempting to work with simple variables, such as a char, etc. For example, if you're attempting a read() operation from user space, and you've asked for 50 bytes of data from a module that manages a serial port, you'll end up having the potential of a loop that requests 50 reads from the serial port hardware. For every successful read, you'll use <kbd>put_user()</kbd> to copy that byte into the user buffer.</p>
<p>In the sample code, we check to see that we've still got data left in our sample data buffer (the pointer <kbd>module3_sampledata_pointer</kbd> is moved ahead after each read). If not, we simply indicate zero bytes left to read. Think about top level functions in Linux programming ... if we attempt to read beyond the end of the file, an fread() or read() will indicate zero bytes avaialble as the return value.</p>
<p>If there are still bytes left, we ensure we don't attempt to read beyond the maximum specified by the user, or that's left in the buffer. We then use <kbd>copy_to_user()</kbd> to copy data from our sample data buffer into the user space pointed to by <kbd>buffer</kbd>, for the correct number of bytes. We move our pointer ahead by the number of bytes "read", and we generate a return value specifying how many bytes have been read.</p>
<h3>module3_release()</h3>
<p>This implementation is simple:</p>
<pre>int module3_release (struct inode *i, struct file *fp)
{
    // indicate that future calls to open() will succeed

    module3_flagopen--;

    printk (KERN_INFO "module3: module3_release ... \n");
}   /* end module3_release */
</pre>
<p>As you can see, we decrement our flag that tracks how many open() operations have been successful, which essentially ensures that future calls to open() will work. Note that when a user level application closes (releases) a device, it doesn't necessarily mean that we have to "close" the device. For example, a serial port really can't be closed internally ... it'll always be ready to generate incoming data for future read operations. We need to be capable of handling that data at all times, thus, a release operation is often just used to support internal housekeeping, as we're doing here.</p>
<p>You can see the full source code for module3 by downloading and extracting the following ZIP file:</p>
<p><a href="module3.zip">module3.zip</a></p>
<p>The archive contains a makefile, the source code (single source file), and the install/cleanup scripts, as discussed earlier in this document.</p>
<p>As with last week, create a new folder to hold the module3 solution. Open a shell window, and <kbd>sudo bash</kbd> to switch into a root level shell. Use <kbd>make</kbd> within your module3 folder to build the module, and then you can use <kbd>./install.sh</kbd> and <kbd>./cleanup.sh</kbd> to install and remove your module, as these operations must be done as root user.</p>
<h2>In-Class Exercises</h2>
<ol>
<li>Using the module3 solution as it stands, build and install the module. Run these commands below multiple times, and match up the resulting behaviour against the open(), read() and release() functionality as discussed above.
<pre>	cat /dev/module3
	head -3 /dev/module3
	tail -2 /dev/module3
</pre>
<p>Can you detect the pattern of the output of these 3 sample commands? Does it make sense based on the implementation of the open() support as discussed above?</p>
<p></p>
</li>
<li>Write a simple C program that performs an <kbd>fopen()</kbd> on <kbd>/dev/module3</kbd>. If the file opens, perform <kbd>fgets()</kbd> operations and output each string read, until there's no more data (<kbd>fgets()</kbd> returns NULL). At that point, <kbd>fclose()</kbd> the device.
<p>Does your solution match that of <kbd>cat</kbd> above? It SHOULD, as that's all <kbd>cat</kbd> does in the commandline above!</p>
<p></p>
</li>
<li>Repeat the simple programming exercise above, this time, using <kbd>fread()</kbd> to read out one byte at a time from the device file. Does your software properly detect the end of file situation based on the work the read() support does in the module?
<p></p>
</li>
<li>Modify the module3 source code, and in the read() support, add in code that detects a VERY SPECIFIC read request: that the user wishes to read from the 13th offset from the start of the "file", and the user wishes to read 1 single byte at that time. If and only if this condition arises, can you determine how you could return a fatal error condition back to the user level application, to simulate a grave error on a device? For example, the module you're writing may detect the hardware it's controlling has gone faulty, and reading may no longer work. Your user level application should be capable of being notified of such a condition. Note that this will require you to do a bit of research on implementation details of read() support in a module! Remember, use the LDD textbook as referenced earlier in this document (pages 50 onwards).
<p></p>
</li>
<li>Research a bit further, and see if you can add in support for <i>seeking</i> within the module data. Think about the meaning of "seeking" within a device driver. Does it make sense? If you're managing the data stream coming in from a serial port, what would it mean to seek 50 bytes ahead in that stream? Do you discard the bytes in the meantime? Is it possible to seek 20 bytes from the "end" of the serial data stream? Again, these are questions that must be pondered when designing a device driver. Although the framework provides these entry points, it doesn't necessarily mean your driver MUST support them.
<p>Of course, since we're simulating a device here, we're free to implement support for seeking. Ensure you don't go beyond the end of the simulated data buffer, or go earlier than the start of the simulated data buffer. Test out our adjustment by rebuilding module3, and reinstalling it as a module. Write a user level C application that opens the file in binary mode, reads a byte, seeks ahead 2 bytes, and repeat until the file is empty (thus, we're reading every 3rd byte from offset zero within our simulated data). Prove that your module is behaving correctly! Adjust the seek value to again verify that you're seek support is working!</p>
<p>Again, use the LDD textbook pages 50 onwards to support your research.</p>
<p><b>WORD OF CAUTION: fgets(), fread(), fwrite(), etc., are standard library functions for portability, and do things that may be unexpected, such as buffering access to files (which is useful to minimize access to disk files in general). Hence, it may appear that all is working well when you use these functions, even though what your driver is being told is NOT what you expect! Thus, to verify and test your solutions, you should really be using the OS level functions like read(), write() and so forth. Also, you might wish to look up <kbd>setbuf()</kbd> to support unbuffered FILE access.</b></p>
</li>
</ol>
<p>Enjoy! You're getting closer to talking to REAL HARDWARE!</p>
<p></p>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch4"></a></span></span></p>
<h1>Device Driver Development :: Linux Character Drivers - Talking To Hardware</h1>
<p>This page will continue the discussion on how to implement standard character device drivers in the Linux environment. In this document, we will control a simple I/O device - the PC parallel port, to help illustrate concepts such as read/write operations, I/O control operations, and so forth.</p>
<h2>Determine if I/O Ports Available</h2>
<p>Just like how we reserve device numbers and register <kbd>cdev</kbd> objects with the Linux kernel, we need to determine if some other driver already owns access to a given set of hardware I/O ports.</p>
<p>You will need to add some new header files for I/O port access:</p>
<pre>#include &lt;linux/ioport.h&gt;
#include &lt;asm/io.h&gt;
</pre>
<p>The first provides access to registration and deregistration support, the latter allows for direct access to I/O port hardware.</p>
<p>In older revisions of the kernel code, a driver programmer would need to first <i>check</i> whether a range of I/O ports were already allocated by previous drivers, and if nobody had allocated access, reserve the ports for the driver. The problem of this was that it was entirely possible to have the module code pre-empt internally within the kernel, and as a result, the request to check for I/O port ownership could return "free", and then a failure on reservation of ports could occur if another module "got there first" during the pre-emption.</p>
<p>Today, we request the region of I/O ports we need, and check the result of the request function. If NULL, someone else owns the hardware currently (although we're free to use it anyways if we choose). If non-NULL, then we know we're the first to request access to that hardware.</p>
<p>The functions in question are:</p>
<pre>int  check_region (unsigned long start, unsigned long n);

<i>returns success/failure status on the I/O port address starting
at the parameter start, for n I/O ports in a row</i>

struct resource *request_region (unsigned long start, unsigned long n,
	const char *name);

<i>returns NULL on error, else a pointer to a resource structure indicating
the application gained exclusive access to the I/O port region starting
at address start, for n I/O ports in a row, registered to a module
with the name supplied.</i>

void release_region (unsigned long start, unsigned long n);

<i>releases the region reserved with request_region(). Note: only
call this function if you successfully reserved the region using
request_region().</i>
</pre>
<p>Note that the <kbd>check_region()</kbd> has been deprecated, as it's possible to pre-empt while checking within the kernel. The <kbd>request_region()</kbd> function is atomic and safe to use. When you build with the latest kernels, any attempt to use the <kbd>check_region()</kbd> function generates a deprecation warning during the build.</p>
<p>Let's assume we want to reserve access to the I/O port given to the PC parallel port, which is 0x378. We would implement code as follows, within our initialization function of our module:</p>
<pre>    // module global variable
    struct resource *module4_region = NULL;

    . . .

    // inside module initialization function ...
    module4_region = request_region (0x378, 1, module4_name);
    if (module4_region == NULL) {
        printk (KERN_INFO "module4: unable to gain exclusive access to parallel port ... but we'll use it anyways!\n");

        // uncomment the next 2 lines if you wish to exit with an error condition
        // rc = -EIO;
        // goto error_handling_routine;
    }   /* endif */
</pre>
<p>Note that if you choose to ignore the error from requesting a region, you're STILL able to talk to hardware. Note that lack of exclusive access means that you're competing with another module for access to the hardware, thus, your module's attempt to talk to hardware may affect another module's use of hardware. You, as the module developer, must make an educated guess as to whether you really want to use the hardware even though you're not exclusive owner of the hardware.</p>
<p><i>For teaching purposes, we'll use the parallel port hardware regardless of what Linux tells us, even though that isn't the recommended practice. For the long term, you'll need to deallocate the drivers that allocate ownership of the parallel port so that your module is always successful in access to the hardware!</i></p>
<p>Within our cleanup support, we need to deregister our use of the hardware, but ONLY if we had exclusive access:</p>
<pre>    // within the cleanup function ...

    if (module4_region != NULL)
        release_region (0x378, 1);
</pre>
<p>A good discussion of these functions is found here:</p>
<p><a href="http://www.linuxfocus.org/English/November2002/article264.shtml" target="_blank" rel="noopener">http://www.linuxfocus.org/English/November2002/article264.shtml</a></p>
<p>At this point, our module is ready for direct access to hardware.</p>
<h2>Direct Access to Hardware</h2>
<p>Recall our work in <a href="http://www.conestogac.on.ca/~set/courses/year1/embedded/index.html">Embedded Software Development</a> back in semester 2 to communicate with Intel based I/O ports:</p>
<p>To write a byte to an I/O port, such as 0x378, we would implement x86 assembly code such as:</p>
<pre>	mov al, 'A'		// put 'A' out to parallel port
	mov dx, 0x378
	out dx, al
</pre>
<p>and to read from an I/O port, we'd use:</p>
<pre>	mov dx, 0x378
	in al, dx
</pre>
<p>Note that we CANNOT access the <kbd>in</kbd> and <kbd>out</kbd> x86 instructions via C code. The best we can do is call up an assembly written subroutine that implements these instructions on our behalf. In fact, this is the case in the Linux kernel - it abstracts access to I/O ports via this pair of functions:</p>
<pre>// output
void outb (unsigned long port, unsigned char value);

// input
unsigned char inb (unsigned long port);
</pre>
<p>So this provides a means of talking to hardware without worrying about the "true" machine mechanism Intel provides for us.</p>
<p>Thus, we can feed the letter 'A' to the parallel port hardware using the following code:</p>
<pre>	outb (0x378, 'A');
</pre>
<p>What can be easier than that! Remember - the <kbd>inb()</kbd> and <kbd>outb()</kbd> functions will communicate to hardware whether we have exclusive access or not, so again, be aware of your exclusive status, and be prepared that if you trounce on hardware you do not own, you may mess up the Linux environment!</p>
<h2>Putting It Together</h2>
<p>Now that we have the basics, you can find a complete implementation of a sample driver that writes to the parallel port here:</p>
<p><a href="module4.zip">module4.zip</a></p>
<p>The archive contains a makefile and an install/cleanup script pair. Make a new folder, download and unzip this archive, and build (remember to sudo as root user). Note the change in the install script - it will set the read/write access to <kbd>/dev/module4</kbd> to 666 - read AND write are both enabled. Why? Simple - this driver implements read and write support!</p>
<p>You can test this driver using this source code:</p>
<pre>#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

int
main (void)
{
    int h;
    int x;
    char ch, val;

    h = open ("/dev/module4", O_RDWR);
    if (h == -1) {
        printf ("cannot open module!\n");
        return 1;
    }

    for (x = 0; x &lt; 128; x++) {
            ch = (char)x;
            write (h, &amp;ch, 1);
            read (h, &amp;val, 1);
            printf ("we wrote: %d, driver says we just wrote: %d\n", ch, val);
            usleep (250000);
    }

    ch = 0;
    write (h, &amp;ch, 1);
    close (h);

    return 0;
}
</pre>
<p>As alluded to last week, we can't really rely on the f-style functions like <kbd>fread()</kbd> or <kbd>fwrite()</kbd> because the support internal buffering, hence, we'll resort to the OS level <kbd>open()</kbd>, <kbd>read()</kbd>, <kbd>write()</kbd> and <kbd>close()</kbd> system calls. The above code will open the driver for write access, and output 128 values to the driver, one byte at a time, with a 250 msec delay in between each write. The code will read directly after a write, to ensure the sample module4 driver properly buffers the outgoing byte in its internal storage (as the sample code doesn't read anything back from the hardware).</p>
<p>Use the above as a simple test harness for module4.</p>
<h2>In Class Exercise</h2>
<p>Create a module that plays music through the PC speaker port. Review our notes in the <a href="http://www.conestogac.on.ca/~set/courses/year1/embedded" target="_blank" rel="noopener">Microprocessors and Embedded Software</a> for details on access to the PC speaker port.</p>
<p>The work for the driver is to accept a stream of bytes via write() access, which specifies the note to play. The note will be a value such as C1, D1, E1, F1, G1, A1, B1 and C2 (the C above middle C). The first byte indicates the note within an octave, and the second byte represents which octave. You can choose how many octaves to support.</p>
<p>When playing a given musical note, allow the sound to play for 1/10th of a second. To access a time delay within your driver code, you will find another header file will be useful:</p>
<pre>#include &lt;asm/delay.h&gt;
</pre>
<p>which defines three delay functions for you:</p>
<pre>void ndelay (unsigned long nanoseconds);
void udelay (unsigned long microseconds);
void mdelay (unsigned long milliseconds);
</pre>
<p>Choose mdelay() with the appropriate value to specify the 1/10th of a second duration.</p>
<p>Observe the behaviour of your Linux system with this approach. Does implementing a large time delay within the driver affect the overall performance of the system?</p>
<h2>In Class Exercise</h2>
<p>The PC printer port (LPT1) actually has 3 registers available in the I/O space of the PC: 0x378 (data), 0x379 (status) and 0x37A (control).</p>
<p>A discussion of the PC parallel port can be found here:</p>
<p><a href="http://www.interfacebus.com/Design_Connector_Parallel_PC_Port.html" target="_blank" rel="noopener">http://www.interfacebus.com/Design_Connector_Parallel_PC_Port.html</a></p>
<p>and</p>
<p><a href="http://www.doc.ic.ac.uk/~ih/doc/par/" target="_blank" rel="noopener">http://www.doc.ic.ac.uk/~ih/doc/par/</a></p>
<p>Using the timing diagram found on the first page, can you implement some VERY simple code within the supplied <kbd>module4</kbd> source code above to communicate with a real printer to output content? As a minimum, you will need to place data in the data register, wait 500 nanoseconds (1/2 a microsecond), then assert the STROBE signal (set it LOW) (the STROBE is found in the control register), for a minimum of 500 nanoseconds (1/2 a microsecond). Then raise the STROBE back to its non-active state (HIGH). This will require that you read the control register, change the value of the STROBE bit, and write the control register.</p>
<p>You'll find some basic printer control code here:</p>
<p><a href="http://www.conestogac.on.ca/~set/courses/year1/embedded/intel/printer.cpp" target="_blank" rel="noopener">sample printer output code from semester 2</a></p>
<p>That code was meant to be single stepped, as it did no timing whatsoever! However, we don't have that luxury in a driver, thus, we MUST perform some minimal timing to ensure we don't breach the printer timing specification as shown in the timing diagram.</p>
<p>You will find another header file will be useful:</p>
<pre>#include &lt;asm/delay.h&gt;
</pre>
<p>which defines three delay functions for you:</p>
<pre>void ndelay (unsigned long nanoseconds);
void udelay (unsigned long microseconds);
void mdelay (unsigned long milliseconds);
</pre>
<p>Hence, you'll need to use <kbd>ndelay()</kbd> with a parameter of 500 to generate the minimum delays the parallel port should provide to a printer. To be safe, try a higher value, as it doesn't matter if you're <i>slower</i> than the specification says, as long as you're not faster!</p>
<p>See if you can modify the <kbd>module4_write()</kbd> support to correctly talk to a printer, and see if you get data output!</p>
<p>Enjoy! You're now talking to REAL HARDWARE!</p>
<p></p>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch5"></a></span></span></p>
<h1>Device Driver Development :: Linux Character Drivers - One Module - Multiple Devices</h1>
<p>This page will continue the discussion on how to implement standard character device drivers in the Linux environment. In this document, we will extend our knowledge of driver development by looking at the issue of supporting a series of hardware devices with a single module, where the module registers multiple minor device numbes, one for each hardware device it plans to control. When you consider that many computers have multiple common devices such as COM ports, it makes sense to have one common body of code to support the class of device (a COM port in this case), and then at runtime, determine which specific COM port the user application may be requesting support for. This leads into a discussion about kernel level critical region management, which will be important especially in abstracting multiple devices that share common hardware I/O addresses or ports.</p>
<h2>Case Study - Stepper Motor Demo Board</h2>
<p>Last week, we had a lab period where we explored creating modules for various types of hardware connected to a PC parallel port. The modules acted as an abstraction layer to the actual hardware, thus, we could easily control hardware from a user application without knowing anything about the nature of the hardware.</p>
<p>One of the devices we controlled was a pair of stepper motors, wired to the data register of the PC parallel port (0x378). The stepper motors were connected in this fashion:</p>
<pre>bit           7   6   5   4   3   2   1   0
winding       D   C   B   A   D   C   B   A
motor         -------------   -------------
                    |               |
                 motor 1         motor 0
</pre>
<p>As we learned through experimentation, to make the motor move in a specific direction, we turn on the windings in a specified pattern. The pattern is:</p>
<pre>A   AB   B   BC   C   CD   D   DA   and repeat
</pre>
<p>As you can see, by enabling winding A, the motor is pulled to magnetic field generated by that winding. When AB are enabled, the motor is pulled half way between the two. When B alone is enabled, then the motor is pulled to B. By continuing this patter, we can make the motor spin. Reverse the pattern, and we make the motor move in the opposite direction.</p>
<p>The goal of last week's lab exercise was to make "motor 0" (the first motor) spin in either the left or right direction by having a user level application provide the data "L" or "R". All other byte data would be ignored.</p>
<p>Our general algorithm would be as follows, when implementing the support for <kbd>write()</kbd>:</p>
<pre>int
module4_write (struct file *fp, const char __user *buffer, size_t len, loff_t *offset)
{
	int bytes_written = 0;
	char ch;
	const char *tmp;

	printk (KERN_INFO "module4: module4_write ... \n"); 

	tmp = buffer + len - 1;
	copy_from_user (&amp;ch, tmp, 1);	
	bytes_written = 1;
	
	switch (ch) {
	case 'L':
		pos++;
		if (pos &gt; 7)
			pos = 0;
		break;

	case 'R':
		pos--;
		if (pos &lt; 0)
			pos = 7;
		break;
	}

	ch = motor_table[pos];

	outb (ch, MODULE4_PORT);

	module4_lastbytewritten = ch;

	return bytes_written;
}	/* end module4_write */
</pre>
<p>with the following global variables added:</p>
<pre>static int pos = 0;
static char motor_table[8] = { 0x01, 0x03, 0x02, 0x06, 0x04, 0x0C, 0x08, 0x09 };
</pre>
<p>If you study the winding pattern earlier, and map the windings to the parallel port bits for the first motor, you'll see you'll generate the above bit pattern. The position variable keeps track of what motor table value we write into the parallel port to control the first motor. By moving it forward or backward (increment or decrement respectively), we ensure that the motor spins in the direction we choose. As you can see, we only do the work for the bytes 'L' and 'R' - all other bytes are ignored and we instead simply feed out the same motor table value as we had previously.</p>
<h2>Supporting Both Motors</h2>
<p>How would we go about supporting both motors? For example, what if we had two user applications working concurrently. App #1 wants to control motor0 and app #2 wants to control motor1. Can we do this with a single module? The answer is a YES, however, it's not quite as apparent how to achieve this as it is when we're abstracting a SINGLE hardware object in our module.</p>
<p>In this situation, we're essentially attempting to treat the parallel port data as two separate instances of data (low 4 bits for one motor, high 4 bits for the second). It makes no sense for a top level application to have to be aware of what the other motor is up to - thus, app #1 could care less about the motor position or direction of the motor controlled by app #2. Thus, somehow, when an instruction to move motor1 arrives, it cannot alter the current information for motor0, and vice versa.</p>
<p>This solution begs for an extension of our support, so that we can create two nodes within the <kbd>/dev</kbd> folder - one for motor0 and one for motor1. Since we already know we have to allocate and register a <kbd>cdev</kbd> structure for the existing node we wish to install in <kbd>/dev</kbd>, it makes sense that we allocate two minor numbers, and register two <kbd>cdev</kbd> structures for, one for each minor number. This will allow us to create two nodes within /dev.</p>
<p>Our initialization code will need modification, similar to the following ("module4" is now going to become "motor" for the purposes of this next module we are developing):</p>
<pre>// we now need two separate cdev structures for the two nodes

static int motor0_cdev;
static int motor1_cdev;

static struct semaphore motor_semaphore;	// discussed later!

static int __init
initialize_motor(void)
{
	int rc;

	printk(KERN_INFO "motor: initialize_motor() called.\n");

	// allocate a major number for our module, along with 2
	// minor numbers this time! "motor_minor" is our first of
	// two minor numbers. Thus, we'll have minor numbers 
	// 0 and 1 for this driver.

	rc = alloc_chrdev_region (&amp;motor_devicenumber, motor_minor, 2, motor_name);
	if (rc &lt; 0) {
		printk(KERN_INFO "motor: unable to allocate device region.\n");
		goto init_error_0;
	}	/* endif */

	motor_major = MAJOR (motor_devicenumber);
	printk (KERN_INFO "motor: during INIT ... major: %d minor: %d\n", 
		motor_major, motor_minor);

	// initialize and register our character driver's file operations
	// we'll do this TWICE ... once for minor 0, once for minor 1

	cdev_init (&amp;motor0_cdev, &amp;motor_fops);
	motor0_cdev.owner = THIS_MODULE;
	motor0_cdev.ops = &amp;motor_fops;
	rc = cdev_add (&amp;motor0_cdev, MKDEV(motor_major, motor_minor), 1);
	if (rc) {
		printk(KERN_INFO "motor: unable to add cdev struct.\n");
		goto init_error_1;
	}	/* endif */

	cdev_init (&amp;motor1_cdev, &amp;motor_fops);
	motor1_cdev.owner = THIS_MODULE;
	motor1_cdev.ops = &amp;motor_fops;
	rc = cdev_add (&amp;motor1_cdev, MKDEV(motor_major, motor_minor + 1), 1);
	if (rc) {
		printk(KERN_INFO "motor: unable to add cdev struct.\n");
		goto init_error_2;
	}	/* endif */
		


	// now, initialize our access to I/O Port hardware
	// for this example, we're going to try to connect to
	// parallel port. Note that even though we have two
	// "logical" motors to support, there's only ONE parallel
	// port that they're controlled with!

#ifdef THIS_WAS_THE_OLD_WAY_OF_DOING_THIS
	rc = check_region (MOTOR_PORT, 1);
	if (rc) {
		printk (KERN_INFO "motor: unable to gain access to parallel port ... "
			"but we'll use it anyways!\n");

		// uncomment the next 2 lines if you wish to exit with an error condition
		// rc = -EIO;
		// goto init_error_3;
	}	/* endif */
#endif

	motor_region = request_region (MOTOR_PORT, 1, motor_name);
	if (motor_region == NULL) {
		printk (KERN_INFO "motor: unable to gain exclusive access to parallel port ... "
			"but we'll use it anyways!\n");

		// uncomment the next 2 lines if you wish to exit with an error condition
		// rc = -EIO;
		// goto init_error_3;
	}	/* endif */


	// initialize semaphore to control critical regions

	init_MUTEX (&amp;motor_semaphore);	// discussed later

	printk (KERN_INFO "motor: successfully completed init!\n");

	return 0;

	// common error support for initialization

init_error_3:
	cdev_del (&amp;motor1_cdev);

init_error_2:
	cdev_del (&amp;motor0_cdev);

init_error_1:
	unregister_chrdev_region (motor_devicenumber, 2);

init_error_0:
	return rc;
}	/* end initialize_motor */
</pre>
<p>As you can see, it's not a difficult stretch to support multiple minor devices in a single module. The trick, however, will be to take advantage of the multiple minor numbers later in our support code!</p>
<h2>Two Motors with Common Handler</h2>
<p>But the support for a <kbd>write()</kbd> operation is essentially the same for BOTH motors - we select the appropriate value out of the table, and write the value to the parallel port. However, the work for motor1 is slightly different, in that we need to shift the motor table value up by 4 bits, and then feed it out the parallel port. To avoid altering the positional information for motor0, we need to OR the data for motor1 with the existing data for motor0. And of course, vice versa if we're controlling motor0.</p>
<p>This means that we not only maintain a global understanding of the current parallel port value, but we also must differentiate whether the <kbd>write()</kbd> operation is destined for motor0 or motor1.</p>
<p>A quick check at the parameter list for the <kbd>write()</kbd> support function shows us that we're missing a crucial piece of information - the <kbd>inode</kbd> structure. The <kbd>inode</kbd> structure provides us with the module number (the combination of major/minor numbers) of the node being opened in <kbd>/dev</kbd>. Hence, we can't dereference this data during a <kbd>write()</kbd> operation, and hence, it appears we're destined to implement two separate drivers for the two motors!</p>
<h2><kbd>inode</kbd> and <kbd>file</kbd> structures, and <kbd>open()</kbd></h2>
<p>The solution to this quandry comes in the form of a member of the <kbd>file</kbd> structure, which is provided to most of the file operation support functions for a module. The <kbd>file</kbd> structure has a member called <kbd>private_data</kbd>, and is usually set to NULL to indicate "no private data". Hence, if we have this pointer point to some dynamic data that helps us differentiate the access to one motor from the other, we'll be in a position to manage both motors with one <kbd>write()</kbd> support subroutine!</p>
<p>So where do we fill in this private member? In the <kbd>open()</kbd> support function. For a module, the <kbd>open()</kbd> support code is supplied two pointers - the first to an <kbd>inode</kbd> structure, which identifies the node being requested, and the second is a pointer to the <kbd>file</kbd> structure, with the private data pointer.</p>
<p>So during the <kbd>open()</kbd> request, we simply allocate a blob of memory that houses the minor number, and since the work being done on each driver is essentially the maintenance of a position within the common motor value table, then our structure should also have a positional member that is unique for EACH instance of the motor driver being opened.</p>
<p>Consider the following structure:</p>
<pre>#include &lt;asm/semaphore.h&gt;

typedef struct MOTOR_DATA {
	int pos;
	int minor;
	struct semaphore *sem;	// discussed later
} MOTOR_DATA;
</pre>
<p>Note: we will discuss the significance of the <kbd>struct semaphore</kbd> later, when we talk about concurrency.</p>
<p>If we modify the <kbd>open()</kbd> support so that we allocate dynamically one of these structures, and extract the minor number from the user's request to open a node, and initialize the positional data member of this structure, we can tie the address of this structure to the private data member of the <kbd>file</kbd> structure, which is then subsequently passed down to the <kbd>write()</kbd> support (as well as <kbd>read()</kbd> and other functions). Upon <kbd>release()</kbd> we naturally need to deallocate this structure. Notice that we use KERNEL versions of memory allocation and deallocation: <kbd>kmalloc()</kbd> and <kbd>kfree()</kbd> respectively. You will note that <kbd>kmalloc()</kbd> has two parameters: the first is the amount of memory required, and the second is a flag identifying the type of memory allocation, which in this case is memory being allocated for kernel oriented usage.</p>
<p>Let's modify the <kbd>open()</kbd>support code for our next revision of the module, which we'll call <kbd>motor</kbd>:</p>
<pre>// note: two flags, one for each motor, to ensure that only
// one top level app has a given motor open at one time

static int motor0_flagopen = 0;
static int motor1_flagopen = 0;


int
motor_open (struct inode *i, struct file *fp)
{
	int minor;
	MOTOR_DATA *pMotorData;

	// dereference device number from inode structure,
	// and extract the minor number. There are two macros,
	// imajor() and iminor(), which are used to extract the
	// major and minor values out of an inode structure!

	minor = iminor (i);

	printk (KERN_INFO "motor: motor_open for %d starting ... \n", minor); 

	// we will limit out char driver to only allow one
	// user app to connect at one time. why? does it make
	// sense for two or more apps to try to read from some sort
	// of hardware simultaneously? Think of a serial port. If two
	// apps attempt to read, how would the stream of bytes being
	// received or sent be distributed to two applications??
	// Hence, return an error code (EBUSY in this case)

	switch (minor) {
	case 0:
		if (motor0_flagopen) {
			return -EBUSY;
		}	/* endif */
		motor0_flagopen++;
		break;

	case 1:
		if (motor1_flagopen) {
			return -EBUSY;
		}	/* endif */
		motor1_flagopen++;
		break;

	default:
		// a fault ... invalid minor device number!
		return -EFAULT;
	}	/* end switch */

	// at this point, either motor0 or motor1 has been
	// opened, and is now in use once and only once.
	// now we can allocate private data for this request
	// and store away in the file structure for later use.
	// NOTE: you MUST use kmalloc() and kfree() to support
	// kernel level memory allocation. The normal user level
	// malloc() and free() cannot be used!

	pMotorData = (MOTOR_DATA *)kmalloc (sizeof (MOTOR_DATA), GFP_KERNEL);
	if (pMotorData == NULL) {
		return -EFAULT;
	}	/* endif */

	// init our private data appropriately, and store the
	// pointer in our file structure

	pMotorData-&gt;minor = minor;
	pMotorData-&gt;pos = 0;
	pMotorData-&gt;sem = &amp;motor_semaphore;	// discussed later

	fp-&gt;private_data = (void *)pMotorData;

	// this driver will support write operations from the user application,
	// and store data written into our module global variable
	// motor_lastbytewritten ... as we won't support a "true read" from
	// parallel port hardware. Remember, both motors are supported
	// via a SINGLE data port, thus, we ALWAYS need to know what's
	// be last written, so that we don't mess up the other motor's data.
	// however, unlike module4, we won't initialize it to zero here,
	// as we are aware that it may already be in use from another
	// open() request!



	// all is well!

	return 0;
}	/* end motor_open */
</pre>
<p>From the above it's plain to see that it's a bit more tricky to support multiple nodes with a single driver, however, in this case, it's essential, as both motors are driven via the same I/O port. The abstraction layer we're creating hides this detail from top level software, and instead, ensures that all the trickery of managing the two motors is done deep in the bowels of the driver.</p>
<h2>Update the <kbd>write()</kbd> Support</h2>
<p>We can now take advantage of our private data, and support BOTH motor0 and motor1 within a single <kbd>write()</kbd> function.</p>
<p>Study the following support code:</p>
<pre>int
motor_write (struct file *fp, const char __user *buffer, size_t len, loff_t *offset)
{
	int bytes_written = 0;
	char ch;
	const char *tmp;
	MOTOR_DATA *pMotorData;

	// fetch our private motor data structure

	pMotorData = (MOTOR_DATA *)fp-&gt;private_data;

	printk (KERN_INFO "motor: motor_write %d ... \n", pMotorData-&gt;minor); 

	tmp = buffer + len - 1;
	copy_from_user (&amp;ch, tmp, 1);	
	bytes_written = 1;
	
	switch (ch) {
	case 'L':
		pMotorData-&gt;pos++;
		if (pMotorData-&gt;pos &gt; 7)
			pMotorData-&gt;pos = 0;
		break;

	case 'R':
		pMotorData-&gt;pos--;
		if (pMotorData-&gt;pos &lt; 0)
			pMotorData-&gt;pos = 7;
		break;
	}

	ch = motor_table[pMotorData-&gt;pos];

	// ensure we combine the motor table data found above,
	// with the currently existing port data. We mask off
	// the appropriate bits depending if its motor0 or motor1,
	// and then OR in the motor table data, either in the low
	// or high 4 bits.

	// AAA

	switch (pMotorData-&gt;minor) {
	case 0:
		motor_lastbytewritten = motor_lastbytewritten &amp; 0xF0;
		motor_lastbytewritten = motor_lastbytewritten | ch;
		break;

	case 1:
		motor_lastbytewritten = motor_lastbytewritten &amp; 0x0F;
		motor_lastbytewritten = motor_lastbytewritten | (ch &lt;&lt; 4);
		break;
	}	/* end switch */
		
	outb (motor_lastbytewritten, MOTOR_PORT);

	// BBB

	return bytes_written;
}	/* end motor_write */
</pre>
<p>Hopefully you can see that by taking advantage of the private motor data, we can manage the positional information for EACH motor dynamically, and thus, ensure that when a user application affects one motor, it doesn't cause problems with the other motor.</p>
<p>Even though the implementation of the driver is done in C, it should be obvious that this private data structure, allocated on a node by node basic via the <kbd>open()</kbd> support, is VERY similar to private data within a class, that's initialized when a constructor is called. Even the C language, with care, can take on many of the properties we take for granted in object oriented programming environments!</p>
<h2>Concurrency</h2>
<p>The solution above is ALMOST complete. Remember that in our brief discussion about modules, we learned that a module may in fact be rescheduled to run at a later time, if the Linux kernel deems something more worthy of attention. Thus, we have a race condition - we're altering the value in our global variable <kbd>motor_lastbytewritten</kbd>, and since we can have two opened motors concurrently, there exists a race condition on this adjustment.</p>
<p>In a user level application, we solve this problem with either a semaphore or a mutex. Obviously, since Linux can preempt our module at the kernel level, it only makes sense that the kernel also supports mutex and semaphores.</p>
<p>If you noticed in the code above, there were two comments, marked AAA and BBB. The code between these two comments is our CRITICAL REGION. If support for motor0 is in the middle of this code, adjusting the last written value or in the process of trying to update the hardware, and gets preempted in favour of the support for motor1, the value in the last written value variable can be corrupted. The actual output of the data in this variable to the I/O port is also critical, as we must complete the output of the current data, to ensure the motor(s) are adjusted to their correct positions before any further manipulation occurs.</p>
<p>Note that the semaphore needs to be initialized. Look above in the initialization code, and you'll see a line that appears as such:</p>
<pre>static struct semaphore motor_semaphore;

. . .

// inside the initialization function ...

init_MUTEX (&amp;motor_semaphore);	
</pre>
<p>This code initializes the module global <kbd>motor_semaphore</kbd>, which will be used to monitor access to the critical region of our motor driver. The initialization code ensures that whomever gets to the critical region first, will be allowed in. Do a Google search for this kernel API to find out other ways to set up a mutex!</p>
<p>Note that in our <kbd>open()</kbd> support, we set up the private data structure to point to our shared mutex object. Since each instance of module code (for motor0 or motor1) will be using the same global semaphore, we could just as easily have used the global semaphore, rather than passing around the address of the semaphore, but since we now have a means to supply useful information to file operation functions, we may as well take advantage of that concept!</p>
<p>These are the insertion points for the following chunks of code:</p>
<pre>/*
 * insert in place of // AAA
 */

if (down_interruptible (pMotorData-&gt;sem))
	return -ERESTARTSYS;


/*
 *  insert in place of // BBB
 */

up (pMotorData-&gt;sem);
</pre>
<p>The <kbd>down_interruptible()</kbd> function manipulates the kernel semaphore (allocated and initialized earlier in our modifed <kbd>open()</kbd> support code), and will cause a module to wait until the semaphore becomes available. This is essentially using the semaphore as a mutex object (supporting our required mutual exclusion).</p>
<p>The function uses the term "interruptible" because a user level application can attempt to forcibly terminate at any time, thus, we need to be able to break out of our wait condition in such an event. It is customary to return the <kbd>-ERESTARTSYS</kbd> value, so that the OS knows that it may need to retry the system call once again (depending on what the top level app did to request a termination of the write() operation). If you Google the <kbd>down_interruptible()</kbd> kernel API, you'll find examples of other mutex operations that will wait forever for the mutex to become available.</p>
<p>To release a semaphore, use the companion <kbd>up()</kbd> function.</p>
<h2>Cleanup</h2>
<p>Of course, since we've made use of dynamic allocations, etc., in our modified motor driver, we need to modify the release() and cleanup() support functions to kfree() our allocated memory, as well as deregister the multiple cdev structures we've declared. It is left as an exercise to the student to successfully deallocate these resources.</p>
<p>Remember that the <a href="http://oreilly.com/catalog/linuxdrive3/book/index.csp" target="_blank" rel="noopener">LDD3</a> textbook, chapters 3 and 5, will come in VERY handy in researching the background details beyond the above discussion.</p>
<h2>In Class Exercise</h2>
<p>Work on Assignment #3.</p>
<p></p>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch6"></a></span></span></p>
<h1>Device Driver Development :: Linux Character Drivers - I/O Control</h1>
<p>This page will continue the discussion on how to implement standard character device drivers in the Linux environment. In this document, we will extend our knowledge of driver development by looking at the issue of implementing direct hardware control without the need of a cumbersom protocol support within read/write functionality. We look at this in the context of our motor control driver. We have two motors, and a simple dual motor driver as required for assignment #3 needs the use of special commands that are understood during <kbd>write()</kbd> operations. Instead of that approach, we'll see that Linux allows you to directly control input/output operations via the use of <kbd>ioctl()</kbd> operations.</p>
<p>For the purposes of this discussion, we'll be implementing <kbd>module5</kbd> which will be a simple 7 segment LED driver with <kbd>ioctl()</kbd> support.</p>
<h2>Case Study - 7 Segment LED Board</h2>
<p>In situations like those presented in Assignment #3, whereby a driver programmer wishes to exercise specific input/output operations by creating specialized support in a <kbd>read()</kbd> or <kbd>write()</kbd> situation, may find that supporting the Linux <kbd>ioctl()</kbd> concept generates a cleaner interface to the control aspects of the driver.</p>
<p>In our Assignment #3 situation, we have a need to allow the driver to move to the left or to the right. One might even fathom that down the road, the driver might allow us to say "move 3 steps left" or "move 7 steps right", or perhaps a higher level of abstraction "move 27 degrees left", and so forth.</p>
<p>Or consider the module5 requirements to control the 7 segment LED. We may wish to support the top level abstraction to write a specific bit pattern to the device (individual bit control), or have support to output a specific glyph (hex digit from $0 through $F). That's two specific variations on output where a protocol might be more cumbersome to support.</p>
<p>These situations are not easily handled using <kbd>read()</kbd> or <kbd>write()</kbd> as a driver would have to now support a specialized protocol. For example, one might try to implement support for <kbd>L(3)</kbd> or <kbd>R(7)</kbd> or even <kbd>LD(27)</kbd>, and so forth. As we all know, implementing protocol support means parsers, verification of parsed information, and lots of error checking to ensure a protocol is correctly adhered to by the user level application.</p>
<p>The <kbd>ioctl()</kbd> concept is simple. Modules that support this interface from user level to kernel level export a series of command values to user level software that allow the user software to issue specific top level abstracted commands directly to the driver module.</p>
<p>The file operations structure has a member called <kbd>ioctl()</kbd>, with this prototype (assuming we're implementing module5):</p>
<pre>int module5_ioctl (struct inode *i, struct file *fp, unsigned int cmd, unsigned long arg);
</pre>
<p>As you can see, the <kbd>ioctl()</kbd> request has plenty of supplied information, such as the <kbd>struct inode</kbd> for the device in question (perfect for support of multiple devices such as motor0 and motor1), the <kbd>struct file</kbd> object (in case we need knowleedge of information such as # bytes written thus far, etc.), a command, and an argument for the comment. You can view this <i>almost</i> like the support for a Windows message, in that you're issued a message (command) and parameters for the command. If event processing in Windows became easy to support using that model, supporting hardware level control operations will be equally simple using this model.</p>
<p>As you can imagine, the support for <kbd>ioctl()</kbd> will be handled using a large <kbd>switch()</kbd> statement within our handler function, detecting the value provided in the parameter <kbd>cmd</kbd>. This parameter will be a special value that is exported to the application via a header file that is shared. For the purposes of this sample module, we'll have a header file called <kbd>module5.h</kbd>, which will supply the command values shared between user level and kernel level. We'll have this file installed in <kbd>/usr/include/module5</kbd> for sharing purposes.</p>
<h2><kbd>ioctl()</kbd> Commands</h2>
<p>As discussed in <a href="https://lwn.net/Kernel/LDD3/ch06.pdf" target="_blank" rel="noopener">LDD3 Chapter 6</a>, the command values to support the <kbd>ioctl()</kbd> operations should be unique across drivers, as it's entirely possible for a user level application to open the <i>wrong</i> module at user level, and if you pass an input/output command inadvertently to this incorrect driver, havoc may ensue. Thus, the comamnd values should hopefully be unique to your driver, so that the wrong driver won't bother supporting your command.</p>
<p>There is a file in the kernel headers called <kbd>include/asm/ioctl.h</kbd> that will supply you with macros that help support the creation of valid input/output command values.</p>
<p>What we need to know is that <kbd>ioctl()</kbd> commands consist of four bitfields:</p>
<pre><b>type</b>      - a "magic number". as documented in <a href="http://www.mjmwired.net/kernel/Documentation/ioctl-number.txt" target="_blank" rel="noopener">this documentation file</a>. This is an 8 bit value.
<b>number</b>    - an 8 bit ordinal (sequential) value.
<b>direction</b> - a value that indicates read/write orientation for the command
<b>size</b>      - generally 13 or 14 bits wide
</pre>
<p>Linux provides a series of macros in the above referenced header file, that helps define command numbers effectively. Refer to LDD3 chapter 6 for the details, however, we'll provide a few sample commands below based on the conventions adopted in LDD3 chapter 6:</p>
<pre>/*
 * module5.h
 *
 * Public constants and other details to allow user level applications
 * to communicate with module5 via ioctl operations
 */

#ifndef __MODULE5_H__

// use 0xC0 as an unused magic number (see documentation link above)

#define MODULE5_MAGIC       0xC0

// we'll define four commands for our module:
// 0 - a generalized reset command (will turn off LEDs)
// 1 - a write command to output raw bit pattern value
// 2 - a write command to output a glyph based on value
// 3 - a read command to retrieve last known value written to LEDs

#define MODULE5_IOCRESET    _IO(MODULE5_MAGIC, 0)
#define MODULE5_IOCSPATTERN _IOW(MODULE5_MAGIC, 1, int)
#define MODULE5_IOCSGLYPH   _IOW(MODULE5_MAGIC, 2, int)
#define MODULE5_IOCGVALUE   _IOR(MODULE5_MAGIC, 3, int)

#define MODULE5_MAXCOMMANDS 4

#define __MODULE5_H__
#endif
</pre>
<p>This file should be copied into <kbd>/usr/include/module5</kbd> for future use by user applications. A system administrator will need to create the folder and copy the file in with read permissions for all users.</p>
<p>The naming convention above uses Sxxxx for a "set" operation, while Gxxxx is used for a "get" operation. This helps abstract the lower level input/output operations for top level user applications.</p>
<p>Within the module header, you can set the appropriate segments of the command using these macros:</p>
<pre>_IO()   - indicates a command with no parameter
_IOW()  - indicates support for writing to the driver, and
_IOR()  - indicates support for reading from the driver. There's
_IOWR() - to support reading and writing for bidirectional commands
</pre>
<p>For the latter 3 macros, the size of the incoming data is supplied as a data type, which in this case will be an integer value. The module will have access to user space for memory of the supplied data type size. Thus, for reading and writing values, the user application will supply the address of an integer as an incoming value, and we'll be able to extract knowledge of how much memory is allowed to be accessed by extracting knowledge of the size information.</p>
<p>Within our driver, we can extract information using these macros:</p>
<pre>_IOC_TYPE(cmd) - get the type value
_IOC_NR(cmd)   - get the command number
_IOC_DIR(cmd)  - get the direction
_IOC_SIZE(cmd) - get the associated data size
</pre>
<p>As you can see, we'll be supplying an integer of information to support our input/output operations, which makes sense here. In future modules, choose a data type that best suits your input/output commands, although most likely, all you'll have is an integer.</p>
<p>The return value of an <kbd>ioctl()</kbd> operation should indicate success or failure. As customary, zero indicates success, and failure can be either -EINVAL (invalid argument) or the POSIX standard -ENOTTY which signifies (inappropriate ioctl for the device). The latter is generally preferred, although both are valid error condition codes. Also the flag -EFAULT can be used to signify a fault in accessing user level data.</p>
<p>It should be noted that there are pre-defined input/output commands, that are handled higher up in the kernel, and are never provided to your device module. See LDD3 chapter 6 for details.</p>
<h2>Capabilities</h2>
<p>There are times where a module may want to limit access to input/output control capabilities to specific types of users or types of access. There is a CAPABILITY feature built into the kernel to allow detection and restriction of access based on capabilities. For example, a serial driver might allow any user to change baud rates, but a tape driver might restrict the selection of a block size to system administrators only.</p>
<p>Some of the more common capability flags include:</p>
<pre>CAP_NET_ADMIN - does the user have network administrative access
CAP_SYS_ADMIN - does the user have system administrative access
CAP_SYS_RAWIO - does the user have access to raw i/o operations
CAP_SYS_MOUDLE - does the user have ability to load/remove modules
. . .
</pre>
<p>Check LDD3 chapter 6 for more details. As an example, to determine if user has system administrative capability, the following code could be inserted into a module, to prevent an <kbd>ioctl()</kbd> operation from being performed by non sys-admin types:</p>
<pre>if (!capable (CAP_SYS_ADMIN))
	return -EPERM;
</pre>
<p>The error code -EPERM would indicate a permissions problem, which is another valid error condition for an <kbd>ioctl()</kbd> operation.</p>
<h2>Putting It Together</h2>
<p>The support code for module5's <kbd>ioctl()</kbd> will look like the following:</p>
<pre>int
module5_ioctl (struct inode *i, struct file *fp, unsigned int cmd, unsigned long arg)
{
	int val;
	char glyphs[16] = { 
		// insert appropriate patterns for hex digits
	};

	// ensure we've got correct magic number and command makes sense

	if (_IOC_TYPE(cmd) != MODULE5_MAGIC)
		return -ENOTTY;

	if (_IOC_NR(cmd) &gt;= MODULE5_MAXCOMMANDS)
		return -ENOTTY;

	// verify that our read/write operations are possible. Note
	// that when user level wants to read, we have to verify that
	// the kernel has WRITE ACCESS to the supplied user level pointer,
	// and that if the user app wants to write, that the kernel has
	// READ ACCESS to the suplied user level pointer. It seems
	// odd to do this, but we're validating the pointer supplied as
	// an argument here! If there's a failure, return -EFAULT

	if (_IOC_DIR(cmd) &amp; _IOC_READ)
		err = !access_ok (VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) &amp; _IOC_WRITE)
		err = !access_ok (VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	
	if (err)
		return -EFAULT;

	// note that if you decide not to do the above access checking,
	// you can always use put_user() and get_user() as alternatives,
	// as obth of those will return non-zero to indicate invalid
	// access to user space. If you do implement the above, then
	// you can use __put_user() and __get_user() as faster ways
	// of accessing hardware.

	switch (cmd) {
	case MODULE5_IOCRESET:
		// turn off all LED segments
		outb (0x80, MODULE5_PORT);
		break;

	case MODULE5_IOCSPATTERN:
		// get pattern from user memory, and output

		__get_user (val, arg);
		outb (val | 0x80, MODULE5_PORT);
		break;

	case MODULE5_IOCSGLYPH:
		// get glyph value from user memory, and output
		// matching bit pattern

		__get_user (val, arg);
		val &amp;= 0x0F;	// use only low 4 bits as index into glyph table
		outb (glyphs[val] | 0x80, MODULE5_PORT);
		break;

	case MODULE5_IOCGVALUE:
		// give the last value written back to user space
		val = module5_lastbytewritten;
		__put_user (val, arg);
		break;

	default:
		return -ENOTTY;
	}	/* end switch */

	return 0;
}	/* end module5_ioctl */
</pre>
<p>As you can see, this is a pretty clean implementation. Remember that since the inode structure is supplied, you can differentiate amongst various instances of module nodes if necessary, hence, if you're implementing Assignment #3, you'll be able to determine which motor you're dealing with. The <kbd>switch()</kbd> statement makes for easy to maintain, easy to implement support for the module. This definately is a much easier approach to implement control support for a driver, compared to building a protocol to support in a <kbd>read()</kbd> or <kbd>write()</kbd> situation.</p>
<p>You will find a complete implementation of module5 at:</p>
<p><a href="module5.zip">module5.zip</a></p>
<p>which includes an example of splitting the project into multiple source files for better maintenance of the overall solution.</p>
<h2>User Level Access To <kbd>ioctl()</kbd></h2>
<p>From the user level application, there is a top level serivce request called, naturally, <kbd>ioctl()</kbd>, which allows the user application, via a device handle, to call up a specific input/output command.</p>
<p>Here's an example of using the <kbd>ioctl()</kbd> support we've just implemented:</p>
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;fcntl.h&gt;

#include &lt;module5/module5.h&gt;

int
main (void)
{
	int h;
	int x;

	h = open ("/dev/module5", O_RDWR);
	if (h == -1) {
		printf ("cannot open module!\n");
		return 1;
	}	/* endif */

	// call up reset request, no parameters
	ioctl (h, MODULE5_IOCRESET);

	for (x = 0; x &lt; 16; x++) {
		// call up write pattern request, supply parameter
		ioctl (h, MODULE5_IOCSPATTERN, &amp;x);
		sleep (1);
	}	/* end for */

	close (h);

	return 0;
}	/* end main */
</pre>
<p>The above code is self explanatory. Note that <kbd>ioctl()</kbd> from the user perspective allows untyped (or variable sized parameter) list, as not every request has an argument to supply.</p>
<p>Notice the similarity between Windows and Linux here, in that the wParam and lParam parameters of a window procedure can be used in any fashion desired (integer values, pointers, etc.), which is similar to how the 3rd parameter for <kbd>ioctl()</kbd> can be a normal integer or pointer as required.</p>
<h2>In Class Exercise</h2>
<p>Work on Assignment #3. To ensure highest possible quality marks, consider expanding on the required <kbd>ioctl()</kbd> support by adding in the ability to indicate now many steps to move left or right on the stepper motor. Note that you may wish to implement a generalized (non-argument) LEFT/RIGHT command pair, and a separate parameterized (argument supplied) version of LEFT/RIGHT to indicate the number of steps to move. What's the difference? A bit of code to manipulate the motor correctly! Why stop short when you can provide a great amount of abstraction to the user layer!</p>
<p></p>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch7"></a></span></span></p>
<h1>Device Driver Development :: Linux Interrupt Handling</h1>
<p>This page will discuss how to deal with interrupts, which are an important aspect to writing software support for digital hardware. As we learned in earlier classes, hardware will issue interrupts whenever the hardware demands to be 'serviced' by software. This is important, as otherwise, software would have to constantly check to see if hardware needed servicing. This latter approach to supporting hardware is called POLLING, and is inherently inefficient in dealing with hardware. A keyboard that is not being touched by a human being does not need servicing. Only when a key is pressed, does the hardware need to be serviced to retrieve the keyboard data. Hence, if you're constantly stuck checking and waiting for hardware to tell you things, you waste CPU cycles doing unproductive work. If we offload that support to interrupt handlers, that get invoked ONLY when hardware indicates it needs support, we ensure we manage the hardware in the most efficient manner possible.</p>
<p>In today's embedded environment, battery management is highly important, and as a result, the ability to put a system to "sleep", and waking up ONLY when the user is interacting with the device, ensures that battery life can be maximized.</p>
<h2>Installing Interrupt Handlers</h2>
<p>As we've seen with other facilities, Linux offers some kernel APIs that allow you to request and install interrupt support for a given interrupt on your CPU.</p>
<p>The APIs in question are:</p>
<pre>int request_irq (unsigned int irq, 
	irqreturn_t (*handler)(int, void *, struct pt_regs *), 
	unsigned long flags, const char *dev_name, void *dev_id);

void free_irq (unsigned int irq, void *dev_id);
</pre>
<p>Note that the <kbd>request_irq()</kbd> API has 5 parameters - the second parameter is a pointer to a function that will be used to support the interrupt you plan on "hooking" using this API.</p>
<p>The last parameter, called <kbd>dev_id</kbd> above, is an arbitrary 32 bit value. You can use this parameter to supply instance oriented data to your interrupt handler. Remember the issue we had in trying to determine what instance of the motor driver was in use at the time a <kbd>read()</kbd> or <kbd>write()</kbd> call was being handled within the motor driver? We overcame that by setting up a private pointer in the <kbd>file</kbd> structure to point to instance oriented information. This <kbd>dev_id</kbd> pointer can also be used in a similar fashion.</p>
<p>The second parameter above is a pointer to a function that handles the interrupt. This function will have a look and feel similar to the following:</p>
<pre>irqreturn_t my_interrupt_handler (int irq, void *dev_id, pt_regs *regs)
{
	// do the work necessary to support the interrupt here

	return IRQ_HANDLED;
}	/* end my_interrupt_handler */
</pre>
<p>The return value of your interrupt handler is generally IRQ_HANDLED, however, since in some systems interrupts are shared, you MUST determine whether the interrupt itself is really destined for your handler, and if your handler was invoked due to another device that shares your interrupt, you will return IRQ_NONE to flag to Linux that your driver did no useful work to support the interrupt, hence, another interrupt handler will be needed to complete the interrupt cycle. How do we know whether or not an interrupt is destined for our handler? Remember that virtually ALL hardware that generates interrupts will also have a status register that can be read to see whether an "interrupt flag" bit is enabled. If so, the flag bit indicates that an interrupt is currently active. If not set, the interrupt was not generated by that particular piece of hardware. This is how drivers can support multiple devices on a single interrupt line, as different devices can easily be distinguished using this mechanism.</p>
<p>As always, a return value of zero on <kbd>request_irq()</kbd> will indicate successful capture of the interrupt.</p>
<p>See page 260 of <a href="http://oreilly.com/catalog/linuxdrive3/book/ch10.pdf" target="_blank" rel="noopener">Chapter 10</a> of the LDD3 textbook for details on the APIs described above.</p>
<p>Interrupt handlers can be installed whenever a driver is first initialized or when a driver is first opened by an application. The former is simple, in that it makes sense to request your IRQ when your driver is loaded. However, in some environments, like a PC, devices often share interrupts, thus, if one driver snags an IRQ permanently, it may prevent a driver for a second device that shares the IRQ to never be able to gain access to the interrupt.</p>
<p>Hence, the latter location is better, in that if and when an application makes a request to open a module, will the interrupt handler be installed. This maximizes the potential for interrupt sharing amongst devices.</p>
<p>Note that if you allow more than one application to open your module, you will need to keep track of the number of times the module has been opened, so that during the release support, you can decrement the count to determine when to free the interrupt handler support.</p>
<p>Upon installation, the Linux operating system will report on what interrupts are in use in the file:</p>
<pre>/proc/interrupts
</pre>
<p>On a typical Linux system, this file might appear as such:</p>
<pre>           CPU0
  0:         76   IO-APIC-edge      timer
  1:         10   IO-APIC-edge      i8042
  6:          4   IO-APIC-edge      floppy
  7:          0   IO-APIC-edge      parport0
  8:          3   IO-APIC-edge      rtc
  9:          1   IO-APIC-fasteoi   acpi
 10:          0   IO-APIC-edge      MPU401 UART
 12:        102   IO-APIC-edge      i8042
 14:    1994849   IO-APIC-edge      libata
 15:   40200046   IO-APIC-edge      libata
 16:          0   IO-APIC-fasteoi   uhci_hcd:usb1
 17:          0   IO-APIC-fasteoi   uhci_hcd:usb2
 18:          0   IO-APIC-fasteoi   uhci_hcd:usb3
 19:          0   IO-APIC-fasteoi   ehci_hcd:usb4
 20:    3355717   IO-APIC-fasteoi   eth0, Intel 82801DB-ICH4
NMI:          0
LOC:   29566146
ERR:          0
MIS:          0
</pre>
<p>Note that Linux will assign interrupts to different CPUs in a multiple CPU environment. The numbers in the list indicate the number of times a given interrupt has been called. As you can see above, the ATA (hard disk) support has been called many times!</p>
<p>Another file of interest is:</p>
<pre>/proc/stat
</pre>
<p>which will contain a line that will appear as such;</p>
<pre>intr 45552302 76 10 0 2 2 0 4 0 3 1 0 0 102 0 1994900 40201432 0 0 0 0 3355770 0 0 0 0 0 0 
</pre>
<p>The first number is the total number of interrupts, followed by a list that indicates the number of interrupts for specific IRQs, starting at IRQ 0. As you can see, IRQ 15 has been invoked many times!</p>
<h2>What Interrupt to Use?</h2>
<p>In some cases, such as a PC parallel port, you may know in advance what IRQ to snag, which in this case would be IRQ 7 for a normal PC parallel port.</p>
<p>Sometimes, you may not know in advance. As a kernel module developer, you may need to <b>probe</b> for an interrupt when your module first loads. The process is fairly easy, handled in part by a pair of kernel APIs:</p>
<pre>unsigned long probe_irq_on (void);
int probe_irq_off (unsigned long mask);
</pre>
<p>The idea here is to have your module call up <kbd>probe_irq_on()</kbd> and force the hardware you control via your module to generate an interrupt. Keep track of the return value, as it indicates a <i>mask</i> of what interrupts are currently being handled versus those that are not. This value must be supplied as the parameter for <kbd>probe_irq_of()</kbd> once you're finished with the probe.</p>
<p>Linux, during the probe, will keep track of a count of which IRQ is generated by your hardware. When you turn off your probe, the resulting value will indicate which IRQ your hardware generated, or a zero to indicate "no interrupts". A negative value indicates an ambiguous situation.</p>
<p>As an example, your module may perform the following work to determine what IRQ the hardware you control uses:</p>
<pre>unsigned long mask;
int irq;

mask = probe_irq_on();

// do something with hardware to
// force an interrupt to occur

udelay (5);	// wait a small amount of time for interrupts to register
irq = probe_irq_off (mask);

if (irq &lt;= 0) {
	// cannot locate an interrupt! remedial action required!
} else {
	// snag the interrupt!
	request_irq (irq, my_handler, SA_INTERRUPT, "my module", NULL);
}	/* endif */
</pre>
<p>Note that you can also install "dummy" handlers for all available interrupts, and then manually probe your hardware by doing something that generates an interrupt, and having your dummy handler mark which IRQ was generated. Release the dummy handlers and check which dummy handler was invoked - that will be your IRQ for your hardware.</p>
<p>So even in the event that you have no idea what your hardware generates, the probing concept is easy enough to implement in any driver.</p>
<h2>Top and Bottom Halves</h2>
<p>As we saw in RTOS, the role of an interrupt handler is to get in, do your work, and get the heck out, as fast as possible. We do NOT loiter inside an interrupt handler. Thus, work that takes an appreciable number of CPU clock cycles may not be the kind of work you may want to have running in an interrupt handler. Lengthy processing loops, etc., should be sent off to perhaps high priority applications, or rewritten to avoid spending inordinate amounts of time in the interrupt handler.</p>
<p>An alternative is to split work into two pieces that run at the kernel level - the first piece is the "fast" and "important" work to immediately service the needs of hardware, and the second piece is the "slower", and more "time consuming" work, that still needs to run at kernel priviledges, but isn't as time dependent in terms of immediately servicing hardware.</p>
<p>Linux has this concept available in teh form of "top" and "bottom" halves.</p>
<p>A "top half" is an interrupt handler that manages the immediate needs of the hardware it is supporting. The "bottom half" is a chunk of driver code that is scheduled to run at a later time, when its safer to take extended CPU time to accomplish the remaining work of the interrupt. Often, this is referred to as a "safer" time to do processing.</p>
<p>Consider a scanner, connected to a PC via an RS232 port. The driver will listen to the serial port, and upon reception of each interrupt, will snag the data from the serial data port, and place into driver memory (a buffer) to store the incoming byte stream. However, the scanner uses a protocol to report its information, thus, the decoding and processing of a packet of information from the scanner is NOT something you would want to do as interrupts arrive. port protocol driver. Thus this initial piece of the interrupt puzzle is considered the "top half" of the driver.</p>
<p>The post-processing of the packet data, sitting in the buffer, is done in a separately scheduled chunk of driver support, called the "bottom half". The top half, upon processing the interrupt, will ask Linux to schedule the bottom half code to run at its convenience.</p>
<p>Linux supports top/bottom half processing in two ways: scheduling the execution of <i>tasklets</i>, or through the use of <i>workqueues</i>.</p>
<p>A tasklet is essentially a "mini program" that gets called up by the Linux kernel whenever it's free to execute these back halves of interrupt handlers. A tasklet is a simple function, accepting one 32 bit piece of information that is programmer defined. Generally, a zero is passed in. It is declared, and registered using the following APIs:</p>
<pre>void do_my_tasklet (unsigned long my_data);
DECLARE_TASKLET (my_tasklet, do_my_tasklet, 0);

tasklet_schedule (&amp;my_tasklet);
</pre>
<p>Again, Linux will schedule the work within <kbd>do_my_tasklet()</kbd> to run at its convenience. Note that it is entirely possible that more than one interrupt arrives BEFORE the bottom half has a chance of running. Make sure you're not dependent on having a bottom half complete before a top half, as otherwise, you really aren't taking advantage of this distributed computing scenario!</p>
<p>The second approach to handling back half processing is to register the tasklet function on a <i>workqueue</i>. We initialize support for a workqueue using the following:</p>
<pre>static struct work_struct my_workqueue;

. . .

INIT_WORK (&amp;my_workqueue, (void (*)(void *)do_my_tasklet, NULL);
</pre>
<p>where <kbd>do_my_tasklet()</kbd> is defined as it was above. Note that the init macro above will fill in the <kbd>work_struct</kbd> with the tasklet function you wish to queue up, and the workqueue expects a function that returns void, and accepts a void pointer as arbitrary data. Our original tasklet function above doesn't quite match this, however, since we rarely use the incoming long integer in our tasklet anyways, it really doesn't matter if we accept it as an arbitrary long integer, or an arbitrary 32 bit pointer.</p>
<p>To actually schedule the workqueue:</p>
<pre>schedule_work (&amp;my_workqueue);
</pre>
<p>Again, Linux will perform the work on the workqueue at its convenience.</p>
<h2>Interrupt Driven Input/Output</h2>
<p>For devices like serial ports, network interfaces, parallel ports, etc. where a stream of data is to be written to the hardware, or read from the hardware, reading and writing should ONLY occur if the hardware indicates data is present.</p>
<p>Consider reading from a serial port. When a data byte arrives, the hardware will interrupt the CPU indicating successful reception of the byte. We handle the interrupt, taking the byte from the serial port's data register and storing it away somewhere, typically, in a driver managed buffer, so that future <kbd>read()</kbd> operations can then pull that data out of the buffer if it exists. Hence, buffer oriented queue support is generally used in this situation. The <kbd>read()</kbd> side of this is actually fairly easy to implement.</p>
<p>However, consider writing to the serial port. This is a bit more complex, in that bytes can ONLY be written to the serial port data register if and only if the serial port has successfully written a value out the port!</p>
<p>Hence, during your <kbd>write()</kbd> support, you need to verify that it's OK to actually write to the data register by checking the serial port flags, and if and only if the flags indicate "no data being sent", would you actually plug a byte into the serial data register.</p>
<p>All other bytes that follow while a byte is currently being sent, must be buffered up <i>somewhere</i>. Again, employ a buffer based queue where you insert outgoing data into the queue, and use an interrupt handler to trigger upon successful output of a given byte. The interrupt handler must then take the next available byte out of the queue, and feed that out, until all available bytes have been sent. Again, it's a one byte at a time style output operation in a serial port, however, once the <kbd>write()</kbd> support in your module kick starts the process, the interrupt handler takes care of feeding out the remainder of the available bytes in the buffer.</p>
<p>Remember to take advantage of things like circular buffers with head and tail counters (buffer based queues) to manage the data for input/output that arrive or are sent via interrupt handlers. It's advantageous to use interrupt handlers as it simply makes no sense in polling for the opportunity to send within your read/write handlers in your module. Let the hardware signal when it's OK to read/write, and thus, share the input/output knowledge between your interrupt handler and your read/write support via these types of buffer structures.</p>
<p></p>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch8"></a></span></span></p>
<h1>Device Driver Development :: Linux USB Driver Basics</h1>
<p>This page will introduce the basics of Linux based USB driver support. USB support is well documented in LDD <a target="_blank" href="http://oreilly.com/catalog/linuxdrive3/book/ch13.pdf" rel="noopener">Chapter 13</a>, so use it as a reference on USB capabilities within Linux.</p>
<h2>USB Concepts</h2>
<p>USB is a replacement for original RS232 type interfacing to a PC, and is meant to be a much more consumer friendly means of connecting simple peripherals to a computer. It doesn't necessarily mean its better than mormal RS232, however, due to the electrical specifications for USB, higher throughput in terms of bits per second, plus plug and play capability, make USB a much more versatile interconnection means than normal RS232. Note that many industrial situations will still depend on RS232, as its a more rugged specification electrically than USB, which has distance issues to contend with in terms of wiring, and is more "delicate" an interface from an industrial perspective.</p>
<p>Linux provides USB support in two layers - custom USB device drivers and a common USB "core" that manages the standardized communications support that all USB devices require. Since USB allows any type of hardware to be connected, the work of managing the flow of data to/from the USB device is common, what the stream of data is to be sent out, or what to do with the stream of data arriving, is device dependent. Hence, a good chunk of USB work can be handled via the core, leaving only the device dependent sections for our driver to implement.</p>
<p>As you can imagine, this situation sounds like a prime opportunity to use a <i>framework</i> to take advantage of the core to support this common functionality, and to farm off to our custom written code the necessary bits and pieces of support for our device itself.</p>
<p>USB devices communicate with the PC via <i>endpoints</i> - these are unidirectional "pipelines" where information flows in from device to computer (an IN endpoint), or where information flows from computer to device (an OUT endpoint). Endpoints come in 4 flavours:</p>
<ul>
<li>CONTROL - used to support configuration and control access to the USB device, and to retrieve status from the device. Every USB device has a control endpoint called "endpoint 0" that the USB core in Linux uses to configure a device at the moment its inserted into the PC.</li>
<li>INTERRUPT - this type of endpoint is used to transfer small packages of information at fixed rate whenever a host asks for data from the device. This is how mouse or keyboard data arrives. Bandwidth for data transfer is guaranteed by the USB protocol.</li>
<li>BULK - this type of endpoint is used to transfer unusually large amounts of data, where bandwidth may or may not be guaranteed. If a block of data cannot be sent through in bulk in one shot, USB protocols allow the block to be broken into multiple smaller pe of endpoint is useful for devices that have large data requriements, but still require all data to eventually get there (guaranteed delivery).</li>
<li>ISOCHRONOUS - this type of endpoint is similar to bulk, however, there is no guarantee that the data ever arrives. Unlike bulk, which can slow down transmission by splitting large blobs into multiple smaller blobs via the USB protocol, this type of endpoint can deal with "loss" of data. Video and audio devices work like this, in that the flow of information is constant, but it's OK to lose a packet or two along the way without totally messing up the experience. For audio, we might hear noise in output, or for video, we may see jerkiness in the incoming video data, however, the stream still works as anticipated for the most part.</li>
</ul>
<p>USB drivers can indicate what kinds of endpoints are present by defining a structure called <kbd>struct usb_host_endpoint</kbd> along with <kbd>struct usb_endpoint_descriptor</kbd>. Attributes such as direction, the style of endpoint (control, interrupt, bulk, etc.), and packet size and interval are specified using this latter structure.</p>
<p>The members of this latter structure are named not in a Linux manner, but in a USB specification manner, as USB is cross-platform. Hence, be aware of the fact that many USB concepts are borrowed directly from the USB specification, and are not handled in traditional Linux manners.</p>
<p>USB devices are further bundled into <i>interfaces</i>, which handles the endpoints for a given device, to create a <i>logical</i> device from a user's perspective. A mouse, for instance, may have a control and an interrupt pair of endpoints, however, the interface is simply a "mouse" interface that bundles the two endpoints. Another structure exists, <kbd>struct usb_interface</kbd> us used to create this bundle of endpoints for a Linux driver.</p>
<p>Again, refer to Chapter 13 of LDD3 to learn more about the basics of USB configuration.</p>
<h2>Sysfs and Usbfs</h2>
<p>USB devices are far more comprehensive than traditional input/output devices, hence, they warrant their own special file system entry points, known as the <i>sysfs</i>. This is a virtual file system (much like <kbd>/dev</kbd>) and can be viewed by listing the contents of the <kbd>/sys</kbd> folder.</p>
<p>USB devices can be found in <kbd>/sys/devices/pci0000:00</kbd>, where enumerated and supported USB devices may be found, such as root hubs, etc. If you scan through this folder, you'll find all kinds of details about all available USB devices, such as product IDs, vendor IDs, configuration details, and so forth.</p>
<p>USB information can also be found in the <kbd>/proc</kbd> folder, under <kbd>/proc/bus/usb</kbd>, where connected devices can be located. This node of the <kbd>/proc</kbd> folder is called the <i>Usbfs</i> and exposes information in an alternative means than the Sysfs.</p>
<h2>Setting up a USB Driver</h2>
<p>As with normal kernel modules, a USB driver must register itself with the USB core and the Linux operating system. There is a structure that defines entry points and other details that must be provided by a USB driver (remember that a good amount of work is already supported by the core). This structure is called <kbd>struct usb_driver</kbd>, and has member such as "owner" (same ideas as the file operations structure), "probe" (a function pointer which will be used at the time the device is plugged in so that your driver can decide whether it really wants to handle the USB device just detected), and "disconnect", which is the support that is called when the user unplugs a USB device that is currently supported. There are other members such as "ioctl" to support IOCTL operations to the device, and support for suspension and resumption of use of the USB device.</p>
<p>As you would expect, there is a way to register your USB support, via the kernel API <kbd>usb_register (struct usb_driver *)</kbd> and to deregister, use <kbd>usb_deregister (struct usb_driver *)</kbd>.</p>
<h2>Conclusion</h2>
<p>At this point, it's safe to say that USB drivers are COMPLEX. There is a lot of detail that goes into managing a USB device, however, the rewards are considerable in that USB devices are a universal means of connecting consumer devices to modern computers. Plug and play support, and the convenience of the high bandwidth offered over USB ensures that this type of driver will be a required driver model for years to come.</p>
<p>Review <a href="http://oreilly.com/catalog/linuxdrive3/book/ch13.pdf" target="_blank" rel="noopener">Chapter 13</a> of the LDD3 textbook for full details. For your final exam, you should be aware of the basic concepts behind:</p>
<ul>
<li>registration and deregistration of USB support in your module</li>
<li>the concept of a URB and what that means for end point communications</li>
<li>basic details of the sysfs and usbfs</li>
<li>how probe and disconnect do their work</li>
</ul>
<p>The details above are meant to be general concepts (theory) rather than specifics in practice. You will not be required to implement a USB driver in this course, however, you should be able to make heads or tails of an existing USB driver in order to maintain and enhance the work of existing driver code.</p>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch9"></a></span></span></p>
<h1>Device Driver Development :: Introduction to Windows Driver Development</h1>
<p>This document will provide some introductory details about Windows drivers and development techniques for Windows. It will leverage existing knowledge about drivers from our look at Linux, hence, our learning curve should be significantly reduced as a result of our initial foray into the world of driver development.</p>
<h2>Windows Driver History</h2>
<p>Microsoft Windows was born from the MS-DOS world, and in fact, early versions of Windows required DOS to be booted first, and Windows run as an executable from the DOS prompt.</p>
<p>Windows in those early days would technically be able to utilize well written drivers for MS-DOS, but soon required better support to deal with the ever increasing need to virtualize/abstract devices away from direct hardware access to a more coherent model that disallowed direct access for software security and stability reasons. Back in the DOS days, each application could assume full control and access to any device supported. In Windows, access was <i>shared</i> for the first time, thus support for shared access had to be added to the driver models of MS-DOS. There were other issues, such as "real" versus "protected" mode support of those early versions of Windows.</p>
<p>Microsoft created, back in the Windows 3.0 days, a new type of driver, called a Virtual Device Driver, or <b>VxD</b> for short. The "x" in VxD represented "any device", such as "Virtual Video Device" or "Virtual Hard-Disk Device", and so forth. The VxD was implemented as a framework, not unlike what we see in Linux drivers. Programmers had to follow the programming model of VxD drivers, and ensure that hardware access was properly abstracted away from top level application developers.</p>
<p>VxDs had extensions of <kbd>.386</kbd> back in the Windows 3.x days, and <kbd>.VXD</kbd> in the Windows 95 days. VxDs written for Windows 3.x could be used in Windows 95, but the reverse was not true.</p>
<p>Although there was an attempt at a framework for VxD drivers, in essence, most drivers were written from scratch, as the model was loose and few resources to help automate driver development existed. The complexity of the model was astounding, and manufacturers complained vehemently about the steep learning curve with VxD development. Something had to be done!</p>
<p>Windows NT which was introduced between Windows 3.x and Windows 95, had its own unique driver model, called the "NT Driver Model", and was incompatible with the VxD concept. Again, the NT driver model had a large learning curve, causing numerous complaints from hardware manufacturers who looked at Windows NT as a problem OS to support. Windows NT drivers had the extension <kbd>.SYS</kbd>, which is still an extension seen today in Windows XP and Vista (check out your <kbd>C:\WINDOWS\SYSTEM32\DRIVERS</kbd> folder to find dozens upon dozens of driver files. Once again, something had to be done!</p>
<p>Note that hardware manufacturers who wished their products to be used in DOS, Windows 3.x, Windows NT and Windows 95, had three different drivers to write and maintain! Something had to be done (are you seeing a pattern yet?) Thankfully, MS-DOS has all but disappeared apart from specialized industrial environments, and Windows 3.x is long dead, with Windows 95 soon to follow. Windows NT versions 3.5 and 4.0 are also obsolete, as are their NT Driver Model drivers.</p>
<p>So something WAS done!</p>
<p>Microsoft released Windows 98, which had yet another driver model to deal with: Windows Driver Model, or <b>WDM</b> for short. WDM was a huge advancement in Windows driver development, in that it unified many disparate driver environments into one model that would (hopefully) be usable for the longer term. And for the most part, the WDM did a pretty good job. WDM drivers were support in Windows 98, ME, 2000, XP (32 bit) and Vista (32 bit). With WDM Microsoft introduced the concept of a "miniport" driver, which supported functionality for hardware such as USB, audio, SCSI and network adaptors, and relied on functionality provided in other WDM drivers already loaded within the system.</p>
<p>With WDM, programmers had to deal with plug and play, power management, input/output requests, and handle all of these simultaneously based on the state of a driver. Microsoft provided "simple" notes on the various states a driver might fall into, such as six different plug and play states and six different system power states. Already you can see where WDM drivers could get a bit hairy!</p>
<p>WDM still had a horrific learning curve, and had been criticized by many driver developers as being a bear for development. There are difficult to control situations with power management (an after thought for Microsoft), and plug and play issues abound. This causes problems where a Windows system may go to sleep or hibernate, only to never reawaken correctly due to driver bugs. Far too much custom code is needed for each type of driver, making it a developer nightmare compared to the utter simplicity of a typical Linux driver. But compared to earlier driver models, it wasn't a bad cut at creating a framework for the future.</p>
<p>Obviously, something had to be done!</p>
<p>Finally, with Windows XP and Vista, Microsoft introduced what is hopefully the last major model for driver development, called the Windows Driver Foundation, or <b>WDF</b> for short. The WDF is split into two main types: <b>kernel-mode driver framework (KMDF)</b> and <b>user-mode driver framework (UMDF)</b>. KMDF is available for use right back to Windows 2000 (via downloadable support), while UMDF is meant for XP onwards.</p>
<p>Will this be the end? Only Microsoft knows. As we've all witnessed, driver stability is key to the stability of the OS. Poorly written drivers slow down a system at best, or crash a system at worst. Badly implemented drivers create entry points for virii and trojans that can do damage or compromise system security. Poor drivers make top of the line hardware appear sluggish, or may even underperform compared to older hardware with better drivers! And finally, due to the complexity of Windows driver development, only major hardware manufacturers tackle development of drivers. Contrast this with Linux, where people all over the world reverse engineer Windows drivers and write their own custom Linux support for their favourite hardware.</p>
<p>In our course, we'll take an overview of a few driver models so that you're aware of what's possible: Windows NT drivers, a WDM drivers, and a WDF drivers. We will ignore earlier models as they're no longer relevant.</p>
<p>Links:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/VxD" target="_blank" rel="noopener">VxD Backgrounder</a></li>
<li><a href="http://en.wikipedia.org/wiki/Windows_Driver_Model" target="_blank" rel="noopener">WDM Backgrounder</a></li>
<li><a href="http://en.wikipedia.org/wiki/Windows_Driver_Foundation" target="_blank" rel="noopener">WDF Backgrounder</a></li>
</ul>
<h2>Obtaining the Windows Device Driver Kit (DDK)</h2>
<p>You will need either a Microsoft Live account, or a HotMail account set up. Visit this page:</p>
<p><a href="http://connect.microsoft.com/" target="_blank" rel="noopener">http://connect.microsoft.com/</a></p>
<p>to begin the process. Click on the "Sign In" button, and enter your login data.</p>
<p>Upon login, you'll be directed to the "Dashboard". From there, you can snag the DDK support from:</p>
<p><a href="https://connect.microsoft.com/Downloads/Downloads.aspx?SiteID=148" target="_blank" rel="noopener">https://connect.microsoft.com/Downloads/Downloads.aspx?SiteID=148</a></p>
<p>or use the CD passed around in class to install.</p>
<p>Note: the DDK support will take over 1GB of hard disk space when it's all said and done! Note that you'll have a "special" compiler and linker installed that is tweaked specifically for driver builds. The build process uses (gasp!) a MAKEFILE to support the build process. Hence, driver development in Windows is not unlike some of the concepts you have already seen in Linux, in that you edit your source code using your favourite editor (ie: Visual Studio), but build using a commandline make process. If you Google you will find that some folks have found a way to merge the WDK/DDK support into Visual Studio, however, for the purposes of this course, we'll keep the two separate for clarity.</p>
<p>Some other useful programs you must snag (as we rely on them during our development process):</p>
<ul>
<li><a href="http://www.osronline.com/article.cfm?article=157" target="_blank" rel="noopener">Driver Loader</a> - OSR Online provides this utility to install simple drivers and Windows services (suitable for NT Driver development)</li>
<li><a href="http://www.softpedia.com/get/System/System-Info/DebugView.shtml" target="_blank" rel="noopener">DebugView</a> - A viewer of debug/diagnostic output from drivers, sent via DbgPrint() API</li>
</ul>
<p>Extract the executables from each of the ZIP archives above, and place them into an easy to remember location. We recommend <kbd>C:\DRIVERS</kbd> as a standard folder for Windows driver development.</p>
<h2>Windows NT Drivers</h2>
<p>Although this type of driver has long been supplanted by WDM and WDF drivers, it's still a useful starting point for studying Windows drivers. NT drivers have a "classic" feel to them, in that they're somewhat reminicient of Linux drivers, with of course, far more complexity due to Microsoft being Microsoft!</p>
<p>Let's create our first Windows driver. First, we need a development folder. Let's assume we'll use:</p>
<pre>C:\DRIVERS
</pre>
<p>Within this folder, create a subdirectory called <kbd>WINDRV1</kbd> to represent our development folder for our first Windows driver. Our development folder is thus: <kbd>C:\DRIVERS\WINDRV1</kbd></p>
<p>A minimal driver for the NT Driver model would be the following:</p>
<table bgcolor="#FFE0E0">
<tbody>
<tr>
<td>
<pre>/*
 * windrv1.c
 *
 * This is a first cut at a Windows NT Driver. It provides the
 * minimal framework to allow for an NT driver to load and unload
 * at runtime.
 */

/*
 * required header files
 */

#include &lt;ntddk.h&gt;

/*
 * void WndDrv1_DriverUnload (PDRIVER_OBJECT pDriverObject);
 *
 * This function provides the "unload" support needed for runtime
 * unloading of the driver.
 */

void
WndDrv1_DriverUnload (PDRIVER_OBJECT pDriverObject)
{
    DbgPrint ("WinDrv1: WinDrv1_DriverUnload() called\n");
}	/* end WndDrv1_DriverUnload */


/*
 * NTSTATUS DriverEntry (PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
 *
 * This function provides the standard entry point for all Windows drivers.
 * It will initialize the DRIVER_OBJECT structure provided with the
 * entry points necessary for this driver. In this case, only the
 * "unload" function is provided.
 */
 
NTSTATUS
DriverEntry (PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    DriverObject-&gt;DriverUnload = WndDrv1_DriverUnload;
	
    DbgPrint ("WinDrv1: DriverEntry() called\n");
	
    return STATUS_SUCCESS;
}	/* end DriverEntry */
</pre>
</td>
</tr>
</tbody>
</table>
<p>Copy the above and save it into our development folder under the name <kbd>windrv1.c</kbd>.</p>
<p>As you can see, right off the bat we use a new header file never before used in Windows developemnt to date: <kbd>ntddk.h</kbd>. This header file provides the basic elements we need to ensure a smooth compile of a Windows driver.</p>
<p>You will notice two functions are present: <kbd>DriverEntry()</kbd> and <kbd>DriverUnload()</kbd>. <kbd>DriverEntry()</kbd> harkens back to our Linux "init" function that must be registered with the Linux kernel. In a Windows driver, the <kbd>DriverEntry()</kbd> function is an expected entry point within the driver <kbd>.SYS</kbd> file, hence, there will always be one. All other functions in a Windows driver are optional. This entry point is called when the driver is first LOADED.</p>
<p>The <kbd>DriverUnload()</kbd> function is <i>registered</i> within <kbd>DriverEntry()</kbd> via the <kbd>PDRIVER_OBJECT DriverObject</kbd> pointer provided. This again harkens to the <kbd>struct file_operations</kbd> concept in Linux. We fill in the members that are necessary, and keep the remainder untouched.</p>
<p>You can learn more about this <kbd>PDRIVER_OBJECT</kbd> object here: <a href="http://msdn.microsoft.com/en-us/library/ms805988.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/ms805988.aspx</a>.</p>
<p>As was the case in Linux, this structure has members that are actually function pointers. The DRIVER_OBJECT structure contains members that are important for driver initialization. Note that the function <kbd>DriverEntry()</kbd> <b>must</b> be present and have this exact name. Windows expects the driver to have a function by that name.</p>
<p>The member <kbd>DriverUnload</kbd> must point to a function that has the appropriate prototype for an "unload" function. Again, visit the MSDN site for the prototype of the "unload" function (use the link on the page above). Note that unlike <kbd>DriverEntry</kbd>, the name for the "unload" function can be programmer defined, as we showed above.</p>
<p>If you leave this entry empty, you will NOT be allowed to unload a driver at runtime!</p>
<p>Next, we need a makefile:</p>
<pre>!INCLUDE $(NTMAKEENV)\makefile.def
</pre>
<p>Save under the name: <kbd>makefile</kbd> in the same folder as the source file above.</p>
<p>In addition to the makefile, you need a secondary file that lists the source information. This file is called <kbd>sources</kbd> and is structured as follows:</p>
<pre>TARGETNAME = windrv1
TARGETPATH = obj
TARGETTYPE = DRIVER

INCLUDES   = %BUILD%\inc
LIBS       = %BUILD%\lib

SOURCES    = windrv1.c
</pre>
<p>Copy and paste that data into the file called <kbd>sources</kbd>.</p>
<h2>Building the Driver</h2>
<p>Our development folder should now have 3 files:</p>
<pre>windrv1.c
makefile
sources
</pre>
<p>We are now ready to build. Click your start button, and locate the Windows Driver Kits entry within All Programs. If you open this up, you'll find a single node that lists the WDK version, and if you open this up, you'll find a node labelled "Build Environments". From this, locate the Windows XP node, and within that node, ensure you select the "Launch Free Build Environment" shortcut. This opens up a command prompt that is pre-configured for building "free" Windows drivers (unchecked drivers). This allows for test builds and is suitable for use in our classroom environment.</p>
<p>Once the command prompt is running, switch to your development folder (for example, <kbd>C:\DRIVERS\WINDRV1</kbd>) and type in:</p>
<pre>nmake
</pre>
<p>Note: <kbd>nmake</kbd> is the Microsoft make utility.</p>
<p>The build process will begin, similar to what we saw in Linux. The makefile relies on a standard one available within our WDK installation folder, and relies on the <kbd>sources</kbd> file to provide a list of the files needed for this driver.</p>
<p>Upon successful build, you'll find a folder called <kbd>objfre_wxp_x86</kbd> which contains an <kbd>i386</kbd> subdirectory, and within that, the file <kbd>windrv1.sys</kbd>, which is our <b>driver</b>.</p>
<p>woo hoo!</p>
<p>Copy the driver from that folder to our <kbd>C:\DRIVERS</kbd> root folder for easy reference. Thus, we should now have a driver available called:</p>
<pre>C:\DRIVERS\windrv1.sys
</pre>
<h2>Windows NT Driver Installation</h2>
<p>Earlier you were told to download the OSR utility called "Driver Loader". If you've extracted it from the ZIP archive and placed it into the <kbd>C:\DRIVERS</kbd> folder, you can now type in this command from the command prompt:</p>
<pre>C:\DRIVERS\OSRLOADER
</pre>
<p>In the field "Driver Path", enter the path to the new SYS file we just created: <kbd>C:\DRIVERS\windrv1.sys</kbd>.</p>
<p>In the field "Display Name", enter the name <kbd>windrv1</kbd>.</p>
<p>The remaining settings can be left alone.</p>
<p>Click on the "Register Service" button. This instructs Windows to register our NT Driver. This utility is actually using a Windows API called <kbd>CreateService()</kbd> to perform the registration work. Visit the "Catch22" link below which has an example registration program if you wish to do this manually. As you will see in the sample driver load utility they provide as source code, the work to do the driver loading is significant, hence, use the OSR utility to streamline this.</p>
<p>Now that the driver is registered, we can load and unload using these commands:</p>
<pre><b>net start windrv1</b>

The above will load the driver dynamically. Any debug output
will be readable if you use the DBGVIEW utility downloaded earlier.

<b>net stop windrv1</b>

The above will stop and unload the driver dynamically.
</pre>
<p>As you can see, the commandline operations above are VERY similar to the <kbd>insmod</kbd> and <kbd>rmmod</kbd> commands in Linux.</p>
<p>If you are using DBGVIEW, ensure you choose Capture followed by Capture Kernel and Enable Vervose Kernal Output. These two items must be "checked" in the menu. If so, you'll then be able to see the results of the <kbd>DbgPrint()</kbd> operation called within the driver source code above.</p>
<p>If you see output in DBGVIEW, congratulations. You've built and executed your first driver!</p>
<h2>In-Class Exercise</h2>
<ol>
<li>Experiment with the capabilities of <kbd>DbgPrint()</kbd>. What can you format with it, and how is the information provided within DBGVIEW? Ensure you're comfortable creating diagnostic and debugging output using this function! Also, determine how to use this "debug print" feature from normal applications. You may be very surprised at the overall effectiveness of this utility in ANY runtime debugging situation!</li>
<li>Add in some code that forcibly generates a serious fault, such as trying to dereference a NULL pointer, or doing a division by zero. Note that since drivers are compiled for execution efficiency, trying to write code such as: <kbd>int x = 5; int y = 0; x = x / y;</kbd> won't actually do anything, as the compiler will detect easily detectable division by zero situations. Can you fool the compiler into actually doing a division by zero? (Hint: some members of the DRIVER_OBJECT struct passed in are initialized to NULL)</li>
<li>Make a copy of this project and its source files, into a new folder called <kbd>windrv1b</kbd>. Rename the source file to <kbd>windrv1b.c</kbd> and adjust the <kbd>sources</kbd> file accordingly. Rebuild, and copy the resulting SYS file to <kbd>C:\DRIVERS\windrv1b.sys</kbd>. Use OSRLOADER to install a new driver called "windrv1b" and register it. Now use the <kbd>NET START</kbd> command to load, and attempt to unload the driver. Does it work? How does the "unload" function affect behaviour? Note that you may need to reboot your Windows sytem to unload the driver!</li>
<li>Using MSDN or the WDK documentation sources, determine what the <kbd>MajorFunction</kbd> member of the <kbd>DRIVER_OBJECT</kbd> structure is used for. In particular, can you determine what "major functions" there are, and what their purposes will be? Try to map "major functions" in a Windows driver to those in Linux. Is there a good correlcation of functionality?</li>
<li>Determine how a Windows application gains access to a driver. Recall that in Linux, we simply use <kbd>open()</kbd> to open a node in <kbd>/dev</kbd> that corresponds to the driver we need. We get a handle to the node, and from there, we can read, write or perform i/o control operations with that node. What is the Windows equivalent of this?</li>
</ol>
<h2>Useful Links</h2>
<p>Some useful learning sites for NT style driver development include:</p>
<ul>
<li><a href="windrv1.zip">windrv1.zip</a> - our first Windows driver sources</li>
<li><a href="http://catch22.net/tuts/kernel101" target="_blank" rel="noopener">Another Sample NT Style Driver (Catch22)</a></li>
<li><a href="http://www.codeproject.com/KB/system/driverdev.aspx" target="_blank" rel="noopener">Sample NT Driver (Code Project)</a></li>
</ul>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch10"></a></span></span></p>
<h1>Device Driver Development :: Fleshing Out an NT Driver</h1>
<p>This document will provide some additional details in our quest to create a simple NT device driver. The techniques presented here will appear to be remarkably similar to those we studied in the Linux realm - and proves that driver concepts SHOULD be portable from system to system, even though we know full well that source code will never be, without a sophisticated porting framework.</p>
<h2>Dispatch Routines</h2>
<p>We saw in the Linux world that we can tell the kernel what file operations we wish to support on our kernel module. The <kbd>struct file_operations</kbd> object had to be initialized with pointers to functions that provided the support for various user level file operations, such as opening, closing, reading, writing, seeking, I/O control, and so forth. Our kernel module had to implement these functions, and we plugged in the addresses of these functions into a structure that was then registered with the OS.</p>
<p>Lo and behold, Microsoft has a similar concept. Recall from last week that the <kbd>DriverEntry()</kbd> function received a pointer to a <kbd>DRIVER_OBJECT</kbd> structure. This structure has a member called <kbd>MajorFunction</kbd>, which is an array of function pointers. Each element of the array is a pointer to what Microsoft likes to refer to as a "dispatch routine".</p>
<p>A dispatch routine has a common parameter list:</p>
<pre>NTSTATUS dispatch_routine_name (PDEVICE_OBJECT pDevice, PIRP pIrp);
</pre>
<p>The first parameter provides access to information about the device, and the second parameter provides further details about a given dispatch request, using the IRP object provided. The IRP gives information such as buffers, number of bytes in a given transaction, I/O control values, and so forth. If you think back to the Linux file operations functions, each had slightly different parameter lists, hence, the IRP structure attempts to consolidate the potential for various amounts of data for each dispatch routine into one single structure. This cleans up the driver structure considerably.</p>
<p>As with Linux, if we don't need to support a given major function, then we can leave the entry blank. A common practice is to provide a function that acts as a dummy handler for unimplemented major functions. This allows for useful diagnostics to determine how applications attempt to use the driver.</p>
<p>There are dispatch routines for all the common capabilities we saw in Linux: IRP_MJ_CREATE (corresponds to <kbd>CreateFile()</kbd> API), IRP_MJ_DEVICE_CONTROL (corresponds to <kbd>DeviceIoControl()</kbd> API), IRP_MJ_READ and IRP_MJ_WRITE (for <kbd>ReadFile()</kbd> and <kbd>WriteFile()</kbd> APIs), and IRP_MJ_CLOSE (corresponds to <kbd>CloseHandle()</kbd> API). Note that each of the APIs above from user level software are Windows specific APIs, rather than general wrapper functions like <kbd>fopen()</kbd> and so forth. So to properly exercise test harnesses for your Windows drivers, ensure you use the Windows APIs directly.</p>
<p>You will quite often see code that appears as such during <kbd>DriverEntry()</kbd>:</p>
<pre>for (i = 0; i &lt; IRP_MJ_MAXIMUM_FUNCTION; i++) {
	pDriverObject-&gt;MajorFunction[i] = WinDrv2_UnsupportedFunction;
}	/* end for */

pDriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = WinDrv2_Create;
pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = WinDrv2_DeviceControl;
pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = WinDrv2_Write;
pDriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = WinDrv2_Close;
</pre>
<p>The pointer pDriverObject is supplied via the first parameter to <kbd>DriverEntry()</kbd>, and the functions such as <kbd>WinDrv2_Create</kbd> are implemented by the driver author.</p>
<h2>Registering the Driver for User Application Use</h2>
<p>As was the case with Linux, Windows requires a driver to register itself as a "device" before a user application has a chance of requesting support within a device driver. This is accomplished with the kernel API <kbd>IoCreateDevice()</kbd>. Here is an example of using this function:</p>
<pre>NTSTATUS status;
UNICODE_STRING usDriverName;
PDEVICE_OBJECT pDevice = NULL;

RtlInitUnicodeString (&amp;usDriverName, L"\\Device\\WinDrv2");
status = IoCreateDevice (pDriverObject, 0, &amp;usDriverName,
	FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN,
	FALSE, &amp;pDevice);
if (status != STATUS_SUCCESS) {
	return status;
}	/* endif */
</pre>
<p>In the code above, you'll notice we first generate a UNICODE string that represents the internal device name. This is somewhat reminicent of how Linux requires a device node in <kbd>/dev</kbd> to be exposed based on major/minor device numbers. Windows has an internal object namespace manager that keeps track of registered names, rather than exposing the device names directly through the file system. The capital L in front of the string tells the C compiler that the string is a "large" or unicode string.</p>
<p>Once the driver name is initialized, we can call <kbd>IoCreateDevice()</kbd> passing in the pointer to the driver object (supplied to <kbd>DriverEntry()</kbd>), the unicode string, flags to indicate that our device driver isn't any specific type of device (there are flags to indicate the class of driver such as a battery driver, keyboard driver, etc. Visit the MSDN web site and research this function to see the types of devices you can create here.</p>
<p>The <kbd>FILE_DEVICE_SECURE_OPEN</kbd> is a typical boilerplate flag to represent the devices characteristics. Again, visit MSDN for more details.</p>
<p>The final parameter is the address of the pointer to the <kbd>DEVICE_OBJECT</kbd> structure, which is initialized by this API.</p>
<p>If not successful, bail out of your <kbd>DriverEntry()</kbd> routine with the error.</p>
<p>Now that we've created the device, we can initialize it by configuring some additional internal flag values:</p>
<pre>pDevice-&gt;Flags |= DO_DIRECT_IO;
pDevice-&gt;Flags &amp;= (~DO_DEVICE_INITIALIZING);
</pre>
<p>The above indicates that our device will access I/O data during read/write support directly using kernel mapped addresses from user supplied data pointers, and that we've completed initializing.</p>
<p>Finally, we need to register a "DOS" alias for our driver's name, so that we can open this driver directly using file system ("DOS") APIs within our applications. We do this with the following:</p>
<pre>UNICODE_STRING usDosDeviceName;
RtlInitUnicodeString (&amp;usDosDeviceName, L"\\DosDevices\\WinDrv2");
IoCreateSymbolicLink (&amp;usDosDeviceName, &amp;usDriverName);
</pre>
<p>The <kbd>IoCreateSymbolicLink()</kbd> function generates the "DOS" namespace linkage so that "WinDrv2" can be opened directly from user applications.</p>
<p>At this point, our driver is ready to start doing work on behalf of user level applications!</p>
<p>Note that it's often customary in Windows drivers to mark the <kbd>DriverEntry()</kbd> function via a <kbd>#pragma</kbd> to indicate that the code for this function is used ONCE by the system during the initialization phase, and that once initialization is complete, the code is no longer required. You can do this by inserting this line:</p>
<pre>#pragma code_seg("INIT")
</pre>
<p>in front of the definition of the <kbd>DriverEntry()</kbd> function. This is not a requirement, but it does help minimize the in-memory footprint of your driver in the long run.</p>
<p>All other functions in your driver should be marked as "paged" so that they reside in memory at all times. This is done via:</p>
<pre>#pragma code_seg("PAGE")
</pre>
<p>Again, these are optional, but does help show you understand the use of memory while the driver is loaded.</p>
<h2>Dispatch Functions</h2>
<p>Before we go into too much detail regarding how a dispatch function does its work, we need to take a moment to discuss the role of the two parameters.</p>
<p>The <kbd>DEVICE_OBJECT</kbd> pointer provided gives each dispatch function information about the device that was registered earlier. This may be consulted by the dispatch routine if it needs that sort of "global" data about the device.</p>
<p>More important is the <kbd>IRP</kbd> pointer. The <kbd>IRP</kbd> structure provides details about the "I/O request packet" that the kernel has provided to your dispatch routine. Internally, whenever work needs to be done by the driver, the kernel will package up an IRP and "stack" them so that the driver code, whenever scheduled to run, can then unstack and process the request packets. Hence, the IRP provides a specialized means of packaging the request so that the dispatch routine can decode and perform the appropriate work.</p>
<p>For a typical dispatch routine, to be able to process the request, the routine needs to extract the request's "stacked" information. This is done via code such as this:</p>
<pre>PIO_STACK_LOCATION pIoStack;
pIoStack = IoGetCurrentIrpStackLocation (pIrp);
if (pIoStack == NULL) {
	DbgPrint ("   Error: Cannot get pIoStack!\n");
} else {
	. . . process the stacked information here
}	/* endif */
</pre>
<p>Now that we've got the stacked data pointer, we can dereference details about the I/O request. Since the IRP is a structure that has overlapping internal data (it's actually a structure that holds a union so that the IRP becomes a generic means of passing details around), we need to remap that data using APIs like the one you see above, so that you can pull out the <kbd>IRP</kbd> data in the manner that matches the way you wish to process. Microsoft is chock full of this type of concept, so that functions can all have simple and common parameter lists, even though HOW they may use a parameter may differ. It looks odd, but has benefits in the long term.</p>
<p>No matter what the internal structure is, certain <kbd>IRP</kbd> members are standard, such as the <kbd>Status</kbd> member, which is used to communicate back to the kernel the processing status of the I/O request, and the <kbd>Information</kbd> member, which provides additional details such as the number of bytes processed, etc. Other details include: the user level memory descriptor for incoming data (which needs to be converted to a kernel-safe address before use, similar to how user/kernel level pointers need special consideration in Linux). This information is crucial for read/write processing.</p>
<p>Dispatch routines/functions all have the same basic structure, as alluded to above. The minimal work that a dispatch function should do is the following:</p>
<pre>NTSTATUS
sample_dispatch_routine (PDEVICE_OBJECT pDevice, PIRP pIrp)
{
	DbgPrint("WinDrv2_Create called \r\n");

	/*
	 * perform any special work here to support the create call
	 */

	pIrp-&gt;IoStatus.Information = 0;
	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest (pIrp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}
</pre>
<p>The work above siply indicates that the dispatch routine accepted the request, and did the default processing (which is simply nothing). The <kbd>IoCompleteRequest()</kbd> is a required call to tell the kernel that all the work for the request within the function itself. The flag value <kbd>IO_NO_INCREMENT</kbd> indicates to the kernel that the thread that required this support did not need to be elevated in priority to finish its work faster. Use MSDN to further research this function and how status is provided back to the kernel.</p>
<p>As was the case with Linux, support for "Create", "Read", "Write", "Close", "DeviceIOControl" and so forth, are easily implemented using the skeleton structure above. As with Linux, if errors are detected, one must ensure the appropriate status is returned back to the kernel.</p>
<p>If you study the source code for the <a href="windrv2.zip">WinDrv2</a> project, you'll see examples of dispatch routines. Notice the work being done within the <kbd>WinDrv2_Write()</kbd> dispatch routine - it illustrates converting the user level memory descriptor (provided via the <kbd>IRP</kbd>) into an address that's usable by the kernel:</p>
<pre>char *pData;
int numBytes;

pData = MmGetSystemAddressForMdlSafe (pIrp-&gt;MdlAddress, NormalPagePriority);
if (pData == NULL) {
	DbgPrint ("   Error: Cannot access memory space!\n");
} else {
	numBytes = pIoStack-&gt;Parameters.Write.Length;

	. . . process the memory here, as we now have access to it
}
</pre>
<p>In some ways, the above is simpler than Linux, in that we now have access to the data (a mapped pointer and the number of bytes available). No need to call special kernel routines to copy data back and forth. This should render a faster processing model than what Linux provides, in theory.</p>
<p>In the sample provided, you'll notice that the "write" support will take the provided data from the user level, and format out a hex dump into the <kbd>DbgPrint()</kbd> output. In future drivers, you're obviously required to do something useful with the data in the buffer, such as feeding that out to hardware, and so forth.</p>
<h2>Device I/O Control</h2>
<p>One of the more interesting concepts we saw in Linux was the fact that there were two discrete means of "talking" to your driver - via read/write requests, which are "stream" oriented, and via I/O control requests, which are "command" oriented. A driver may support both, if it makes sense. For example, a simple I/O port driver that exposes an interface that allows top level software to issue a command such as "write byte" or "read byte" would probably forgo the read/write interface support, and instead, concentrate on a command interface.</p>
<p>Thus, Microsoft, just like Linux, supports a major function known as the "Device I/O Control" function. This is identical in nature to the <kbd>ioctl()</kbd> support in Linux.</p>
<p>In the Windows device I/O control dispatch handler, you'll typically perform this kind of work:</p>
<pre>PIO_STACK_LOCATION pIoStack;
char *pData;
int insize, outsize;

pIoStack = IoGetCurrentIrpStackLocation (pIrp);
if (pIoStack == NULL) {
	DbgPrint ("   Error: Cannot get pIoStack!\n");
} else {
	insize = pIoStack-&gt;Parameters.DeviceIoControl.InputBufferLength;
	outsize = pIoStack-&gt;Parameters.DeviceIoControl.OutputBufferLength;
	pData = (char *)pIrp-&gt;AssociatedIrp.SystemBuffer;

	/*
	 * perform the device control as we did in Linux (switch statement)
	 */

	switch (pIoStack-&gt;Parameters.DeviceIoControl.IoControlCode) {
	case MY_FIRST_DEVIOCTL_VALUE:
		// Verify that the incoming data size, and the outgoing
		// data size MATCH what you expect. For example, if
		// you expect a long integer coming in, the insize
		// must be sizeof(long). If the outging data is a string
		// of 6 bytes, then outsize must be (6 * sizeof (char)).
		// If the sizes match what's expected, the pData
		// pointer can now be converted into the correct
		// data types for processing.

		... do work here, reading from pData for input info, 
		... and writing back to pData with output info

		break;

	case MY_SECOND_DEVIOCTL_VALUE:
		... do the work for the second command here ...
		break;

	default:
		DbgPrint ("   Error: unknown DevCtl request\r\n");
		iStatus = STATUS_UNSUCCESSFUL;
		break;
	}	/* end switch */
}	/* endif */
</pre>
<p>As you can see, the handler has an eerie resemblance to the Linux equivalent - obtain the command ID value, and perform a switch. Each case, do the work necessary, and return status.</p>
<p>Note that if your I/O control command processing generates outgoing information, ensure that you indicate, via <kbd>pIrp-&gt;IoStatus.Information</kbd> how many bytes of output you generated. In general, this should be identical to the <kbd>outsize</kbd> value obtained above.</p>
<h2>Device I/O Control Command Values</h2>
<p>As was the case with Linux, when a driver exposes a device I/O control interface via the appropriate dispatch routine, application level software MUST know about the commands. And as was the case with Linux, there is a structure to how the command itself is defined. The command ID is a 32 bit value, being a combination of: device type, control code, transfer type and required access. Microsoft provides a macro that builds the command ID:</p>
<pre>id = CTL_CODE(device_type, control_code, transfer_type, required_access);

where:
device_type:     should be 0x8000 to 0xFFFF for a custom driver
control_code:    should be 0x800 to 0xFFF for a custom driver
transfer_type:   should be METHOD_BUFFERED for most implementations
required_access: should be FILE_ANY_ACCESS for most implementations
</pre>
<p>In the sample "windrv2", you'll see a header file that provides the declarations. This header file, called <kbd>windrv2_devctl.h</kbd> must be shared between the driver AND any application level software that needs that knowledge for device I/O control requests.</p>
<p>It should also be noted that if there's a specific way to pass data in/out of a device I/O control request, this public header file would be a convenient place to define any structures. In general, Microsoft provides a buffer that holds incoming data, and can then be reused to provide outgoing data (internally, this buffer is then copied from/to the user supplied data objects at the top level by the kernel - it's not something you worry about).</p>
<p>For our sample port driver code, there's a structure defined, called <kbd>PORTINFO</kbd> that structures the information needed for port access: the port number and the byte of data. Without this, you will need to manually organize memory, as is shown in many examples of code. Although direct and manual memory organization is fine, it's hard code to manage, hence, a structure may be better. However, ensure that both the driver AND the user level software match in terms of byte packing within structures, otherwise, incorrect dereferencing may occur.</p>
<p>See the sample source code for examples!</p>
<h2>Direct I/O Port Hardware Access</h2>
<p>Study the <a href="windrv2.zip">WinDrv2</a> project to see how a simple I/O port driver can be implemented.</p>
<p>It should be noted that just like in Linux, kernel primitives exist that give us access to I/O port hardware:</p>
<pre>unsigned char value;
unsigned short io_port_address = 0x378;

To read from an IO port, such as the parallel port:

value = READ_PORT_UCHAR ((PUCHAR)io_port_address);

To write to an IO port:

value = 0xFF;
WRITE_PORT_UCHAR ((PUCHAR)io_port_address, value);
</pre>
<p>Pretty simple!</p>
<p>Again, just like in Linux, it may not be technically kosher to whack I/O port hardware directly without performing some sort of discovery that the I/O port exists (for plug and play hardware), and that some other software hasn't already taken ownership of the hardware.</p>
<p>And remember: I/O port hardware may generate interrupts, so it may be necessary to support interrupt processing as part of your solution.</p>
<p>For more details on this, have a read of the chapter called "Interrupt Driven I/O" in the online textbook <a href="http://safari.oreilly.com/0130204315" target="_blank" rel="noopener">Windows 2000 Device Driver Book</a>, which is available for FREE via Safari as a student.</p>
<h2>User Level Access</h2>
<p>At this point, we can discuss how a user level application can talk to our driver. Study the following source code (provided in the "WinDrv2" archive):</p>
<pre>/*
 * test.c
 *
 * A simple Windows test harness for a driver.
 */

#include &lt;windows.h&gt;
#include &lt;winioctl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "windrv2_devctl.h"

int
main (void)
{
	HANDLE hDriver;
	DWORD dwReturn, BytesReturned;
	PORTINFO pi;
	char *s = "Hello from user mode!\nThis is a test!";

	/*
	 * open the driver for read/write access
	 */

	hDriver = CreateFile ("\\\\.\\WinDrv2", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

	if(hDriver != INVALID_HANDLE_VALUE) {
		/*
		 * write some test data to the driver ... watch the
		 * output using DbgView utility
		 */

		WriteFile (hDriver, s, strlen (s), &amp;dwReturn, NULL);

		/*
		 * do some I/O control work here
		 */

		pi.port = 0x378;
		pi.data = 0xFF;
		DeviceIoControl (hDriver, IOCTL_WRITE_PORT_BYTE, &amp;pi, sizeof (pi),
			NULL, 0, &amp;BytesReturned, NULL);

		pi.port = 0x201;
		DeviceIoControl (hDriver, IOCTL_READ_PORT_BYTE, &amp;pi, sizeof (pi),
			&amp;pi, sizeof (pi), &amp;BytesReturned, NULL);

		printf ("got %02X from 0x201\n", pi.data);

		CloseHandle (hDriver);
	} else {
		printf ("can't open WinDrv2\n");
    }
    
    return 0;
}
</pre>
<p>Firstly, notice how we open the driver - a SPECIAL filename is used, with the aliased "DOS" name as part of the special filename. The aliased name (in this case, <kbd>"WinDrv2"</kbd>) is appeneded to the special path <kbd>"\\.\"</kbd> (remember that in C code, we need to escape the backslash). Internally, the namespace object manager in the Windows kernel will map that request to the driver device we registered in <kbd>DeviceEntry()</kbd>.</p>
<p>Once we open the driver, we get a handle. The handle must be checked for <kbd>INVALID_HANDLE_VALUE</kbd> (not NULL or -1) before attempting to use it. If valid, you'll notice the sample code provides an example of using the Windows API <kbd>WriteFile()</kbd> that shows the sending of data to the driver for "write" support. This is used in the sample driver's write dispatch routine, and a hex dump into debug output will occur. The <kbd>WriteFile()</kbd> API is similar to the Linux <kbd>open()</kbd> API, which we use to access the Linux kernel module via its mapped in device filename.</p>
<p>You'll also notice the use of the Windows API <kbd>DeviceIoControl()</kbd> which is very similar to the Linux <kbd>ioctl()</kbd> API. Here the Windows API requires the handle to the driver, the I/O control command ID value (see above in terms of sharing these command IDs between driver and user applications), the location and size of the incoming data, the location and size of the outgoing data, the address of a <kbd>DWORD</kbd> that tells you how many bytes were sent back (should match the size of the outgoing data), and the final parameter is often left as NULL. Note that at user application level, you MUST include <kbd>winioctl.h</kbd> as a system header that provides device I/O control support for user applications.</p>
<p>The examples provided illustrate accessing a given port for both reading and writing. Use this as the basis for other simple port driven hardware.</p>
<h2>In-Class Exercises</h2>
<ul>
<li>take your support for the parallel port hardware in earlier assignments, and rework that support into a parallel port driver for Windows. In particular, try your hand at I/O control of the motors!</li>
<li>with a port driver, can you make music come out of the PC speaker?</li>
</ul>
<h2>Useful Links</h2>
<p>Some useful learning sites for NT style driver development include:</p>
<ul>
<li><a href="http://safari.oreilly.com/0130204315" target="_blank" rel="noopener">Windows 2000 Device Driver Book</a></li>
<li><a href="windrv2.zip">windrv2.zip</a> - our second Windows driver source</li>
<li><a href="http://logix4u.net/Legacy_Ports/Parallel_Port/Inpout32.dll_for_Windows_98/2000/NT/XP.html" target="_blank" rel="noopener">A Sample I/O Port Driver (driver, DLL and test sources)</a></li>
</ul>
<p>The Windows 2000 driver book linked to above is a VALUABLE resource in terms of basic NT style drivers like we're studying here. PLEASE READ THAT TEXTBOOK! It's chock full of material that is perfect for an exam (hint, hint)!</p>
<p>At this point, you have all the details needed to complete <a href="assignments.html">Assignment #5</a> for this course. Enjoy!</p>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch11"></a></span></span></p>
<h1>Device Driver Development :: WDM Driver Basics</h1>
<p>This page will provide some introductory details on the Microsoft Windows Driver Model (WDM) style driver. As you will see, WDM expands on the simple NT driver model, in that it adds a framework that allows driver manufacturers to minimize custom coding to take advantage of common capabilities that all drivers should have. Thus, driver writers generally "plug in" code support into the functions they need to implement, and delegate responsiblity to other layers within WDM.</p>
<h2>NT vs WDM</h2>
<p>There are commonalities between NT and WDM drivers, as well as differences. The similarities consist of:</p>
<ul>
<li>IRP support</li>
<li>standard driver entry point</li>
<li>dispatch routines</li>
</ul>
<p>The differences include:</p>
<ul>
<li>manual driver registration (via application) (NT)</li>
<li>manual driver installation (NT)</li>
<li>driver discovers the hardware on its own (NT)</li>
<li>plug and play discovers driver (WDM)</li>
<li>INF based installation (WDM)</li>
<li>various classes of drivers (WDM)</li>
</ul>
<p>As you can see, the WDM offers some significant improvements over NT style drivers, in terms of installation and use of driver in a normal runtime environment. Gone are the days of users running special installers to get a driver running. With Windows plug and play support, drivers can be discovered to handle specific devices, and as such, Windows will load the driver automatically based on configuration supplied in the INF file. This alone has made Windows dramatically easier to manage than ever in the past.</p>
<p>Another significant improvement is the support of "hot pluggable" devices that the old NT style driver really couldn't manage. The ability to deal with devices being disconnected at any asynchronous time means special support is needed to manage the device that NT drivers didn't require.</p>
<p>In addition, power management is a must in a modern Windows environment, hence, WDM drivers supply intelligent access to power management support within the driver, which a manufacturer can take advantage of to minimize power consumption. An important consideration for laptop and handhelds!</p>
<p>Finally, support for <i>intrumentation</i> is supplied as part of the WDM, so that statistical gathering of run time data can be done on the driver. This allows for administrators to monitor the behaviour of drivers without creating an undue headache from the development perspective to implement such support.</p>
<h2>Driver Stack</h2>
<p>In the WDM world, what a user would consider a driver is really a "stack" of drivers within the operating system. When an IRP is issued by the I/O manager of the Windows kernel, the IRP will be handled by a <i>chain</i> of driver modules, prior to gaining access to the Hardware Abstraction Layer (HAL). We saw a glimpse of the HAL in our previous document, when we saw functionality like:</p>
<pre>WRITE_PORT_UCHAR ((PUCHAR)io_port_address, value);
</pre>
<p>The stack consists of the following:</p>
<table border="1">
<tbody>
<tr>
<td>upper level filter driver (optional)</td>
</tr>
<tr>
<td><b>Function Driver</b></td>
</tr>
<tr>
<td>lower level filter driver (optional)</td>
</tr>
<tr>
<td><b>Bus Driver</b></td>
</tr>
</tbody>
</table>
<p>A <b>Function Driver</b> is responsible for device management, taking advantage of bus access that is supplied by existing <b>Bus Drivers</b> that Microsoft supplies. No longer does a driver need to worry about the interfacing of the device via the bus (USB, PCI, ISA, etc.), as this is now handled by a layer within the WDM, and its a layer that is essentially provided to you by Microsoft. The model already exhibits signs of driver development simplification!</p>
<p>The function driver essentially replaces the old NT style driver in most cases. It is the driver that deals with the specifics of the hardware, in an abstracted manner.</p>
<p>The <b>Bus Driver</b> is responsible for the interconnection of the device to the CPU via a standard bus structure. These bus structures include USB, Firewire, PCI, and so forth. Plug and play support, detection of the device, etc., is all handled via the bus driver.</p>
<p>The optional filter drivers are used to potentially modify the behaviour of a function driver. For example, a high level filter might want to monitor the behaviour of a given driver, perhaps to log activity, or to provide a work-around for a bug in a driver.</p>
<p>A low level filter would be able to intercept IRPs destined for the bus driver layer, and hence, can post-process work that the function driver has done.</p>
<p>Some of the bus drivers that are standard with Windows are:</p>
<ul>
<li><b>Advanced Configuration and Power Interface (ACPI)</b> - this interacts with the ACPI BIOS to enumerate devices and control their power usage</li>
<li><b>Peripheral Component Interface (PCI)</b> - manages the enumeration and configuration of devices on a PCI bus</li>
<li><b>IEEE1394</b> - manages the enumeration and configuration of Firewire devices</li>
<li><b>Universal Serial Bus (USB)</b> - manages enumeration and configuration of devices on a USB bus (both low and high speed USB)</li>
</ul>
<h2>Class Drivers</h2>
<p>Function drivers can be categorized into various classes, called <b>Class Drivers</b>. Class drivers essentially provide a framework for a type of driver, as different drivers perform differen styles of work.</p>
<p>Some examples of class drivers include:</p>
<ul>
<li><b>Stream</b> - provides basic framework functionality for devices that stream information in/out of the PC, in a bandwidth and time critical fashion. This includes video and audio data. Often, these drivers employ <b>minidrivers</b> (see below) for interfacing to actual hardware.</li>
<li><b>SCSI and Optical</b> - provides access to hard disks, CDs, DVDs as file system devices</li>
<li><b>Printer Devices (USB)</b> - supports the transport of content to a USB based printer - minidrivers are often used to supply hardware specific support. This is handled via the Microsoft Universal Printer Driver (Unidrv) architecture.</li>
<li><b>Human Interface Devices (HID)</b> - provides an abstraction on the concept of a human interface device, such as a mouse, joystick or keyboard. Note that HID can also encompass arbitrary communications to an external device, as we've seen in the past with the <a href="http://www.phidgets.com" target="_blank" rel="noopener">Phidgets</a> devices.</li>
<li><b> Still Image Devices</b> - provides a framework to communicate with cameras and scanners in an abstract manner, again, using minidrivers to perform the actual device level communications.</li>
</ul>
<p>A <b>minidriver</b> gets its name in that it is a very simplified driver, based around a common framework. Let's consider a printer or a camera/scanner type device. Most printers and cameras do the same kind of work. A printer takes GDI oriented work, and outputs it to paper, by generating a raster that represents the final page output. The minidriver for a printer would thus handle the output of the raster to the hardware specifics of the printer it controls, while the Unidrv (common printer driver architecture) handles the common work of rasterizing all the top level GDI operations. Thus, the gruntwork for printing is already done, only the device communications specifics need implementation. Same with a camera. Camera/scanner devices supply access to a bitmapped image, thus, the minidriver deals with the device specifics in terms of controlling the capture/scan, and the delivery of content to the common driver architecture.</p>
<p>This concept alone has simplified driver development in areas such as scanners and printers, and thus ensured that manufacturers are free to implement nifty features, knowing full well that the drivers for these features are trivial to implement (in comparison to the work needed in the NT driver model!)</p>
<h2>Driver Stack Example</h2>
<p>To help illustrate the concept of bus and function drivers better, consider an HID keyboard:</p>
<ul>
<li>when the PC is booted up, the PCI bus driver discovers the USB controller, and loads USB bus drivers to support the USB bus</li>
<li>when the keyboard is plugged in via USB, the USB host controller detects the keyboard via plug and play support - the USB bus driver informs the plug and play mangement that a new device has arrived</li>
<li>the plug and play management interrogates the new device to discover its a keyboard - hardware ID information is gathered during this phase</li>
<li>Windows will then search for an INF file that matches the hardware signature (IDs, etc.) of the keyboard. The INF file then provides installation details for Windows to install and activate the appropriate driver code</li>
<li>in this situation, an HID class driver is loaded, and the custom higher level HID keyboard driver is installed</li>
<li>at this point, the HID information provided by the keyboard can be fetched by the USB bus driver support, which provides the information to the HID class driver, which in turn, delivers this data to the HID keyboard driver, which then can provide messages to a top level application indicating keyboard activity.</li>
</ul>
<p>This is complex, however, much of the work is already present in the form of class and bus drivers that Windows provides. Only the specifics of a given keyboard need to be dealt with, hence, custom top level drivers are really all that is needed!</p>
<p>Contrast this with the NT model, where all support, from the USB to plug and play to dealing with USB communications, etc., would all have to be handled in a custom NT driver. This is why Windows NT had non-existant USB support - Windows NT driver writers simply couldn't cope with the overwhelming amount of effort it would take to make USB a reality!</p>
<h2>WDM Software Components</h2>
<p>Most WDM drivers are written using a common set of files to implement the WDM driver features. A link to a sample driver will be supplied, and you will see that the sample driver perfectly implements what Microsoft prescribes as the layout of the WDM driver source code tree.</p>
<p>The components are:</p>
<ul>
<li><kbd>init.cpp</kbd> - This file provides initialization support, much like an NT driver. This includes <kbd>DriverEntry()</kbd>, unload support, and basic configuration as we saw with NT drivers.</li>
<li><kbd>pnp.cpp</kbd> - This file provides <b>Plug and Play</b> support for a device. This includes adding, removing and stopping devices, and to obtain access to hardware resources to allow PnP to work flawlessly.</li>
<li><kbd>dispatch.cpp</kbd> - This file provides access to the common dispatch routines, such as <kbd>Create</kbd>, <kbd>Close</kbd>, <kbd>Read</kbd>, <kbd>Write</kbd> and <kbd>DeviceIoControl</kbd>. These dispatch routines are similar to what we saw in an NT driver.</li>
<li><kbd>deviceio.cpp</kbd> - This file provides serialized access to hardware. Serialized access ensures that we have proper critical region management to ensure that in a multi-CPU environment, we don't have multiple driver threads trying to vie for access to hardware. This file also provides interrupt, DMA (direct memory access) and deferred procedure support for complex hardware (similar to top/bottom half processing in Linux)</li>
<li><kbd>power.cpp</kbd> - This file provides access to power management support. Driver writers can implement code in this file to manage the power usage of your device, to handle sleep and hibernate modes, etc.</li>
<li><kbd>wmi.cpp</kbd> - This file provides common <b>Windows Management Instrumentation</b> (<a href="http://en.wikipedia.org/wiki/Windows_Management_Instrumentation" target="_blank" rel="noopener">WMI</a>) support. This is meant to be a non-proprietary means of gathering information about the performance of the driver, and helps support concepts like <a href="http://en.wikipedia.org/wiki/Simple_Network_Management_Protocol" target="_blank" rel="noopener">SNMP</a> (Simple Network Management Protocol) for Windows.</li>
<li><kbd>eventlog.cpp</kbd> - This file provides support for the NT Event log access. Drivers should announce errors and other important diagnostic information via the event log.</li>
<li>Note that the above may need to pass IRP knowledge to device drivers lower in the chain. Thus, support for interconnections to lower level drivers is necessary in many cases.</li>
<li>there are obviously other files in a WDM project that are custom to the driver itself. The above is merely a minimal project layout for a WDM driver.</li>
</ul>
<h2>Kernel Mode Support Functionality</h2>
<p>Microsoft is world renowned for creating some of the most obtuse naming conventions, and Windows kernel mode programming exposes a driver writer to many new interfaces and routines with ridiculous names!</p>
<p>We've already seen some examples in our previous discussion, such as <kbd>RtlInitUnicodeString()</kbd> and <kbd>IoCreateSymbolicLink()</kbd>.</p>
<p>The following list will help clarify the meaning behind the naming convention, so that you have at least a minimal appreciation as to where to look for kernel functions. Note that the first four we've already seen in the context of our simple NT driver discussion.</p>
<ul>
<li><kbd>Rtl</kbd> - This prefix is given to <kbd>Run Time Library</kbd> functionality. This is the replacement for the user level standard library.</li>
<li><kbd>Ob</kbd> - This prefix is given to <b>Object Manager</b> functionality, as we saw in simple NT drivers.</li>
<li><kbd>Io</kbd> - This prefix is given to <b>Input/Output Manager</b> functionality.</li>
<li><kbd>Mm</kbd> - This prefix is given to <b>Memory Manager</b> functionality, such as support to map virtual addresses to physical kernel mode addresses.</li>
<li><kbd>Ps</kbd> - This prefix is given to <b>Process Structure Module</b> functionality, such as management of kernel mode threads.</li>
<li><kbd>Se</kbd> - This prefix is given to <b>Security Reference Monitor</b> functionality. This provides support for file system driver security checks.</li>
<li><kbd>Zw</kbd> - This prefix is given to <b>User-Mode Functionality</b> that can be accessed via the kernel, such as registry access, file access, etc.</li>
<li><kbd>Ex</kbd> - This prefix is given to internal <b>Executive Library</b> functionality, such as extended memory management, mutex support, etc.</li>
<li><kbd>Ke</kbd> - This prefix is given to internal <b>Kernel Functionality</b>.</li>
<li><kbd>Hal</kbd> - This prefix is given to <b>Hardware Abstraction Layer</b> functionality that abstracts access to hardware.</li>
</ul>
<p>Remember that in a kernel mode driver, you are NOT allowed to use standard library functionality that user applications use. Remember to locate the equivalent in the <kbd>Rtl</kbd> series of kernel functions.</p>
<h2>Example WDM Driver</h2>
<p>Download the following ZIP archive:</p>
<p><a href="http://www.phdcc.com/download/hiimwdm.zip" target="_blank" rel="noopener">http://www.phdcc.com/download/hiimwdm.zip</a></p>
<p>which comes from this web site:</p>
<p><a href="http://www.phdcc.com/wdmarticle.html" target="_blank" rel="noopener">http://www.phdcc.com/wdmarticle.html</a></p>
<p>If you unzip the archive above to your <kbd>C:\DRIVERS</kbd> folder, to a subdirectory called <kbd>wdm1</kbd>, we can discuss the folder tree.</p>
<p>The author of this sample driver has a subfolder called <kbd>SYS</kbd> which will contain the WDM driver. The files in this folder are:</p>
<pre>// "Hi I'm WDM" driver sample project

// headers for this driver
Eventlog.h
HiImWdm.h
resource.h

// source files - note the naming convension is exactly what
// we described earlier!

Init.cpp
Pnp.cpp
Dispatch.cpp
Wmi.cpp
Eventlog.cpp

// support for driver resources (version information) ...
// drivers can have resources too! (after all, they are just
// Windows EXE files with special entry points!)

HiImWdm.rc
HiImWdm.bmf
HiImWdm.mof

// sample INF files for free/checked version of driver

HiImWdmChecked.inf
HiImWdmFree.inf

// makefule support

Sources
MAKEFILE
Makefile.inc
HiImWdm.dsp
</pre>
<p>You will need to add one file to this folder for the build to succeed:</p>
<pre>/*
 * afxres.h
 *
 * a quick and dirty replacement for stupid Visual Studio 
 * resource file management
 */

#ifndef __AFXRES_H__
#include &lt;windows.h&gt;
#define __AFXRES_H__
#endif
</pre>
<p>Save this file under the name <kbd>afxres.h</kbd> in the <kbd>SYS</kbd> folder of this project.</p>
<p>You'll also need to edit the <kbd>Sources</kbd> file to remove one line:</p>
<pre>BROWSER_INFO=1
</pre>
<p>Locate and delete that line of the <kbd>Sources</kbd> file. The latest DDK doesn't require that any longer.</p>
<p>Now you can invoke <kbd>nmake</kbd> to build. You'll notice that the first attempt will come up with a prompt telling you to re-invoke the make, as the first build sets up the paths for the build process, while subsequent builds take advantage of that.</p>
<p>If you study the <kbd>Init.cpp</kbd> file, you'll see its much like the NT predecessor, in that we still must implement <kbd>DriverEntry()</kbd> to configure the driver, and to install the unload support. So far, no real differences.</p>
<p>In <kbd>Dispatch.cpp</kbd>, you'll see handlers for various dispatch routines, as we had implemented in our previous NT driver model example. Again, no real differences here. The sample driver here impements a shared memory buffer that can be written to or read from (similar to our Assignment #2 for Linux!)</p>
<p>The <kbd>EventLog.cpp</kbd> file provides new WDM access to the event log mechanism of WDM. The main infrastructure is supplied via WDM, we simply fill in the blanks for the type of logging we wish to do in our driver.</p>
<p>iThe <kbd>Pnp.cpp</kbd> adds in a lot of support that was simply not feasible under the NT model, to deal with plug and play support. It also encapsulates power management, which shows how to pass requests off to lower level drivers in the driver stack. Again, your driver can choose to do special work here in terms of both PnP and Power management.</p>
<p>Finally, <kbd>Wmi.cpp</kbd> provides support for Windows Management Intrumentation. As you can see, structures are declared and filled in providing common information to top level management support. Again, this is a WDM advancement that NT style drivers really coulnd't support without a lot of custom code.</p>
<p>Read over the main page from where this ZIP archive is downloaded for instructions on installation and other issues, such as testing this driver. As you can see, the test harness supplied does similar types of activities as we've been doing all along for our Linux and NT style drivers. The test application illustrates a unique way of locating the driver by enumerating class devices and locating the driver via its "GUID" (globally unique ID value) that is required for INF based installation. The main web page also describes the functionality of the sample driver in much better detail, <i>so consider this required reading for the purposes of the final exam!</i></p>
<h2>Conclusion</h2>
<p>As you can see, the basic skeleton of a WDM driver isn't overly complex, but it does have significant new features that a driver writer needs to be aware of. In the industry, you may be faced with maintenance of existing WDM drivers, hence, understanding the basic layout, components and layering of WDM driver technology allows you to make heads or tails of WDM projects.</p>
<p>Ensure you read over the following PDF file, which formed the basis of this summary:</p>
<p><a href="http://people.msoe.edu/~atassim/atassi_WDM.pdf" target="_blank" rel="noopener">http://people.msoe.edu/~atassim/atassi_WDM.pdf</a></p>
<p>This article provides a good overview of the basics of a WDM driver, and describes in more detail kernel mode issues such as synchronization, spinlocks for multiple CPU management, and so forth. <i>This is required reading, and exam questions may be based on concepts provided within this document.</i></p>
<p></p>
<p><span style="font-family: ARIAL;"><span style="font-family: ARIAL;"> <a name="ch12"></a></span></span></p>
<h1>Device Driver Development :: WDF in a Nutshell</h1>
<p>This page will provide some introductory details on the Microsoft Windows Driver Foundation (WDF). WDF promises to be the "final" framework for driver development you will ever have to learn, but as always, the proof will lie in how well the industry takes to the new model, and whether Microsoft has had the foresight to encapsulate all of the features and details that have yet to emerge in terms of device driver management.</p>
<h2>Architecture</h2>
<p>WDF splits drivers into two distinct pieces: a kernel level driver architecture known as <b>Kernel Mode Driver Framework (KMDF)</b> and <b>User Mode Driver Framework (UMDF)</b>. KMDF is used to support kernel level driver development, while UMDF is designed to eliminate the need to implement kernel mode software for drivers that really don't need direct access to kernel resources. This latter environment is perfect for USB type devices - a KMDF driver implements the bulk of USB support, while the UMDF supports the higher level specifics of the device itself. This split is designed to ensure that future drivers gain the benefit of user level protection mechanisms, and ensure that issues like "blue screen of death" (BSOD) disappears for UMDF style drivers!</p>
<p>Some of the issues that hurt WDM development include:</p>
<ul>
<li>WDM requires driver writers to manage not only interactions with hardware, but also interactions with the operating system itself!</li>
<li>WDM drivers have thousands of lines of code to support these two types of interactions, which makes them difficult to write, difficult to maintain, and lead to long term errors that are hard to debug.</li>
<li>WDM drivers implement a Device Driver Interface (DDI) that exposes direct kernel structures that are exported directly from the kernel. Incorrect management of DDIs lead to failures and operating system crashes.</li>
<li>The "miniport" style of driver was meant to simplify driver development as the bulk of a driver exists in the minidriver framework, however, there are upwards of 8 to 10 different miniport models, making the learning curve idiotically difficult for something that was touted as a "simplification"!</li>
<li>WDM introduced a user mode driver mechanism, however, there was no attention paid to creating a common framework for user mode drivers, and these user mode drivers did not support plug and play, etc., correctly, leading to poor user experience.</li>
</ul>
<p>WDF was designed to simplify development and improve driver quality without killing performance. It is a unified model that should decrease the overall learning curve, as there's only one model to learn from here on in! The infrastructure supports both user and kernel level drivers, and eliminates much of the boilerplate nonsense that plagued the WDK environment in terms of producing a driver that implemented all interactions correctly.</p>
<p>Microsoft has a number of design goals in mind with WDF that eliminate many of the problems that plague WDM as it currently stands. WDF claims to solve the above problems and provides these design goals:</p>
<ul>
<li>separate the driver model from core kernel functionality</li>
<li>provide a viable user mode development model</li>
<li>the framework will now provide common features that ensure that default operations will always be properly supported, leaving the driver writer to concentrate on handling their actual hardware</li>
<li>drivers are now event driven, allowing writers to manage driver events much like a Windows SDK or MFC application handles events</li>
<li>reduce complexlity of plug and play and power management operations considerably</li>
<li>implement a consistent installation process for both user and kernel mode drivers</li>
<li>implement a toolset that simplifies development and testing</li>
<li>ensures that a single binary can work on multiple operating systems</li>
</ul>
<p>That's a comprehensive list of design goals, and in theory, WDF supplies what it claims it will do.</p>
<p>You can learn more about the WDF basic architecture by reading this whitepaper:</p>
<p><a href="http://www.microsoft.com/whdc/driver/wdf/wdf-arch.mspx" target="_blank" rel="noopener">http://www.microsoft.com/whdc/driver/wdf/wdf-arch.mspx</a></p>
<h2>KDMF</h2>
<p>It should be noted that the WDF kernel mode implements an object model. WDF objects have <b>properties</b>, <b>methods</b> and <b>events</b>. The WDF ensures that there are always default handlers for all events, so that driver writers no longer have to worry about copying and pasting thousands of lines of boilerplate just to ensure all aspects of the driver are fully implemented. This is akin to how a GUI application always can rely on default message processing for messages/events they don't care about.</p>
<p>Some of the WDF kernel mode objects include:</p>
<ul>
<li>WDFDRIVER - represents the driver itself</li>
<li>WDFDEVICE - represents a device</li>
<li>WDFQUEUE - represents a queue of I/O requests</li>
<li>WDFREQUEST - represents an I/O request</li>
<li>WDFINTERRUPT - represents an interrupt resource</li>
<li>WDFMEMORY - represents a buffer of memory for an I/O request</li>
</ul>
<p>Note that these objects are not directly accessable as pointers to classes as you might expect in C++ - rather, these are represented by <b>handles</b>, and APIs exist that dereference the handle to access methods, properties and so forth. This divorces the driver writer from the innards of the kernel, and allows the kernel to continue to evolve without breaking the driver model, as has happened over the years with the various driver models Microsoft has attempted to foist on us unsuspecting driver writers!</p>
<p>A plethora of information regarding kernel mode driver support can be found here:</p>
<p><a href="http://www.microsoft.com/whdc/driver/wdf/KMDF.mspx" target="_blank" rel="noopener">http://www.microsoft.com/whdc/driver/wdf/KMDF.mspx</a></p>
<h2>UMDF</h2>
<p>User mode is supported by a COM (Component Object Model) interface, hence, they can be written much like any COM application.</p>
<p>User mode drivers are meant to implement support for <b>protocol based devices</b> such as USB or Firewire devices. Since the bulk of these drivers are fully implemented within the kernel, user mode drivers deal with the specifics of a given device, eliminating much of the headache in terms of managing these devices and interacting with the kernel. User mode drivers can be written fully in C++ using standard rapid code development techniques. The full Win32 API is available to user mode drivers! Due to the simplified framework, performance is actually on par with fully kernel mode drivers frmo the past, so there's no fear that user mode drivers have inferior performance.</p>
<p>Devices fully supported using user mode drivers include:</p>
<ul>
<li>portable storage devices like PDAs, cell phones, etc.</li>
<li>portable media players</li>
<li>USB bulk transfer devices</li>
<li>secondary display/video devices</li>
</ul>
<p>Full 32 and 64 bit support now exists within the UMDF.</p>
<p>User mode driver information and overviews can be found at this link:</p>
<p><a href="http://www.microsoft.com/whdc/driver/wdf/UMDF.mspx" target="_blank" rel="noopener">http://www.microsoft.com/whdc/driver/wdf/UMDF.mspx</a></p>
<p>and</p>
<p><a href="http://www.microsoft.com/whdc/driver/wdf/UMDF_Intro.mspx" target="_blank" rel="noopener">http://www.microsoft.com/whdc/driver/wdf/UMDF_Intro.mspx</a></p>
<p></p>
<p></p>
</body>
</html>